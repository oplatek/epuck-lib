	This chapter is aimed on a programmer, who wants to start playing with a e-Puck using Elib. 
	Elib offers a lot of tools,which make e-Puck programming easier. 
	Without proper usage the tools are useless. This chapter introduce guidelines and numerous
	examples how to use Elib and avoid probles.
	
	On thirteen samples from TestElib project we present Elib and e-Puck's properties.
	The samples are written in $C\#$ and are densely commented.
	We suggest, that a programmer, who wants to program his e-Puck, starts with one of the examples
	from TestElib project and modifies it according his needs.
	Elib is build robustly and unproper usage does not destabilize the operation system.

	Let us note, that this chapter describe usage of Elib and its tools,
	but does not explain basic .Net or $C\#$ features. Basic knowledge of .Net and $C\#$ language is required
	for understanding Elib examples. On the other hand .Net $delegates$,an $EventWaitHandle$ class and usage of lambda functions in $C\#$
	are shortly introduced. Big part of this chapter is devoted to $IAsyncResult$ interface and its
	usage in Elib.

	Elib library requires .Net 2.0 on Windows and requires Mono 2.0%todo verze mona?
	and higher on Linux.
	As an example of application, which use Elib, is at the end of this chapter presented Elib Joystick.
	Elib Joystick is a graphical application, which uses Windows Presentation Foundation. It requires .Net 3.5 or higher
	and is not portable to Linux.
	Elib can control every actuator and get every sensor value for $BTCom's$ version 1.1.3. Let's remind, that
	$BTCom$ is simple program running on e-Puck. It processed answers sent ovet Bluetooth, do the relevant actions
	and sents confirmation answer back. If we ask for a sensor value, value is added to confirmation message.

	The source codes are doployed using solution of Microsoft Visual Studio 2008 (MSVS) for Windows and MonoDevelop solution for Linux.
	If you use higher version of MSVS or MonoDevelop, than the solution can be easily upgraded.	

	Content of this chapter is devided into 6 sections.
	First section is devoted to advanced .Net techniques, which are used in Elib.
	Second section shortly introduces features of each Elib's interfaces and  on examples presents e-Puck's sensors and acuators.
	Next section goes through samples of implemented behaviours from TestElib project and explains the crucial part of examples.
	Section ~\ref{sec:et} presents the Elib Tools console application, which is handfull during developing a program for e-Puck.
	Finally the last sections sums up the most importing guidelines for Elib library and points out the situations,
	where is useful to prefer one interface before another. 
	It also shortly points out, which algorithms and application can profit most
	from Elib design and which brings problems.
	
\section{Advanced .Net techniques} \label{sec:net}
	Elib interface requires knowledge of $delegates$. Lambda functions and $EventWaitHandle$ class
	are used in TestElib's samples and asynchronous programming is much more comfortable with them.
	If you are familiar with terms above, their usage in Elib will be described in ~\ref{sec:samples} section.
	This section describes them in general.

	Delegates are .Net wrappers for functions. Every .Net language is strongly typed and even functions are typed in .Net.
	An delegate has two meanings in .Net. First meaning is the placeholder type for functions of given type. 
	See the $C\#$ implementation in ~\ref{deleg}. The placeholder type has name $OkfActuators$.
	Second meaning is the placeholder itself. In figure below its name is $a$.

	Delegate variable can contain functions, which exatly match delegate definition. In case ~\ref{deleg} the function must return
	$void$ and it must have one argument of type object. Object class stands above all classes in .Net hierarchy, therefore every object
	can be passed to this delegate. Object class contains method $ToString()$ and therefore the number as well as the string is printed.  
	Delegate function can contain more functions. On the ohter hand this feature is not used in Elib, because it reduces readibility of code.
	

\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
//in some class e.g Program
//delegate definition
delegate void OkfActuators(object data);
void Example(){
	int i=8;
	//declaration of delegate variable and initialization with lambda function
	OkfActuators a = new OkfActuators((sth) => { Console.WriteLine("Lambda f{0},{1}",sth,i); });
	//second function is added to delegate
	a += new OkfActuators(suitableFunction);
	//invocation of 2 functions with string parameter
	a("Hurray!");
	//third function is added to delegate
	ExampleClass c=new ExampleClass();
	a+= new OkfActuators(c.suitableMethod);
	//invocation 3 functions with int parameter.
	a(-333);
}
private static void suitableFunction(object sth) { 
	Console.WriteLine("suitable Function {0}",sth);
}
class ExampleClass{
	public void suitableMethod(object sth) { 	
		Console.WriteLine("suitable method {0}",sth);	
	}
}
/\end{lstlisting}
\caption{Definition of a delegate} \label{deleg}
\end{figure}

%output
\begin{verbatim}
Lambda fHurray!,8
suitable Function Hurray!
Lambda f-333,8
suitable Function -333
suitable method -333
\end{verbatim}

	After exploration of the console output from $Example()$ function it is clear, that the function are called according order, in
	which were added to a delegete variable. Important thing is, that they have no returning value, because there is no chance how to access
	return value from the first function. Delegates allow the last function to return its value, but it is considered a bad manner, because
	another function added to delegate can overwrite the return value of the delegate call.

/	Let us focused on a function, which is used in the $OkfActuators$ declaration. The function 
	was defined and declared in place. Functions defined in place are called lambda functions and have several advantages. 
	They can ommit types of arguments, because they are inferred from delegate definitions. Lambda functions
	can also directly use variables from scope of its declaration. Look at the output. The lambda function printed 8,
	although we have not pass it as argument to the delegate.

	$EventWaitHandler$ class is not tricky itself, but sometimes is used in multithread programming, which is usually complicated.
	An instance of the class is used to synchronize two threads. It is usually used to signal from one thread to another, that some work has been done.
	In Elib are used two methods on $EventWaitHandle$ instance.
	Let us suppose we have $A$ thread running. Lets name the thread, which should perform a long task, $B$. The thread $A$ wants after a while wait until the work of $B$ is finished.
	Before the job on $B$ finishes $A$ will creates $EventWaitHandle$ $e$ with parameters $false$ and $ManualReset$. 
	$False$ parameter sets $e$ to blocking state. In blocking state all thread, which have called method $WaitOne$ on $e$, are synchronously block in $WaitOne$ method. 
	$ManualReset$ means that the state of $EventWaitHandle$ can be changed only by its methods and
	$EventWaitHandle$ does not perform any action itself.
	Back to thread $A$ and $B$. $A$ creates an instance $e$ of $EventWaitHandle$ with mentioned parameters, passes $e$ to second thread. Finally $A$ call $WaitOne$ and blocks on this call.
	$B$ thread is working and after the job is done, it just call $Set$ method on $e$. $Set$ method release all threads, which are blocked in $WaitOne$ method.
	Run the code from ~\ref{ewh} to understand it.

		
\begin{figure}
\begin{lstlisting}[language=cs]
static EventWaitHandle e = null;
static void Athread() {
      Thread t = new Thread(Bthread);
      e = new EventWaitHandle(false, EventResetMode.ManualReset);
      t.Start();
      e.WaitOne();
      Console.WriteLine("Finally someone press the button!!!");
}
static void Bthread() {
      //simulate the work      
      Console.Readline();
      e.Set();
}
\end{lstlisting}
\caption{Definition of a delegate} \label{ewh}
\end{figure}

	 $EventWaitHandle$ is used in function $endBehaviour$ described in section ~\ref{todo} devoted to behaviours implementation.
	 Lambda functions can be seen for example in $ConsoleTestSensorsTimeout$ function, which presents all sensors from e-Puck.
	 Delegates are used in every command invocation to specify types of callback functions.
	 Callback functions are functions, which are called after some operation has finished.
	
\section{Explore Elib through examples} \label{sec:interfaces}
	There are three public classes in Elib. $Sercom$, $Epuck$ amd $Stamp$.
	$Stamp$ is for time measurement. $Sercom$ and $Epuck$ are classes, where all the algorithms are located.
	$Epuck$ class uses $Sercom$ internally.
	Let us focuss only on $Epuck's$ class, because $E-Puck's$ basic interface is specialization of $Sercom's$
	interface for version 1.1.3 of $BTCom$.
	For more information about interfaces and implementation of $Sercom$ and $Epuck$ see section ~\ref{chap:elib}.

	$Epuck$ class itself has two interfaces. Let us name them basic interface and $IAsyncResult$ interface.
	$IAsyncResult$ interface is used widely through .Net. We introduced it on examples from TestElib project.
	All examples from this section come from TestElib project. We suggest read this chapter with TestElib project opened
	and explore examples from TestElib in detail.

	The examples are listed from the simplest to the more complex. 
	Firstly a function, which test the communication between e-Puck and your computer is described,
	then we focus on starting session using $Epuck$.
	Later simple are presented functions, which presents all e-Puck's sensors and actuators using simple $Epuck's$ interface.
	Next functions creates a window, where a captured picture by e-Puck's camera is drawn.
	Four methods, which invokes different behaviours using $IAsynResult$ interface follow.
	One behaviour implemented by $Epuck's$ basic interface is presented.
	After main section, which covers the behaviours, are shown some "tips and tricks".
	There is a behaviour in TestElim, that emulates $Epuck's$ basic interface via $IAsyncResult$. It is depicted in summary of ~\ref{chap:elib}.
	We will skipp it, because it impemented only for teoretic purposes.
	Apart minor functions there is an example of image processing in "Tips and Tricks" part and logging example.
	Logging $Epuck's$ actions is the last example.

	In following paragraphs is by exception meant a subclass of $ElibException$ if is not said otherwise.
\subsection{Set up and disposal of a session}\label{sec:session}
	Let's start with a function, which does not use Elib. $TestPortTurnAround$ opens a given serial port
	and sends some commmadns to move and stop, then it ends. It does not require any feedback and throws no exceptions.
	It is useful to run it, because lot of errors is not hidden in a code, but in hardware set up.

	Function $startEpuck$ return instance of $Epuck$, which allows you later control an e-Puck.
\begin{lstlisting}[language=cs]
      return new Epuck(port, "Ada"); //Name it. It is usefull for logging and debugging.
\end{lstlisting}
	The function throws exception, only if other application blocks the port. Windows remember
	the port, which is set up for communication with e-Puck, therefore
	no exception occurs if e-Puck is not even turn on and was used before.
	In such case $Kof$ callback from $Epuck's$ basic interface or exception	from $IAsyncResult$ are raised after sending a command to e-Puck.
	Sending a command to e-Puck is done via calling one of $Epuck's$ functions.
	i$Kof$ callback and exception let user know, that a command was not delivered in time.
	Let us mentioned the closing of session and then we introduce both interfaces.
\begin{lstlisting}[language=cs]
      //dispose can take a while (under 500ms)
      ada.Dispose();
      TextWriter t= ada.LogStream;
      t.WriteLine("We are trying to reconnect");
      ada.BeginStop(0.1,null,null); //throw an exception
      ada=new Epuck(ada.Port,ada.Name);
      ada.LogStream=t;
      ada.StartLogging();
      ada.Stop();//does not throw an exception
\end{lstlisting}
	The function $endEpuckSession$ sends command to stop your robot, but it primarily close the session by calling $Dispose$ method.
	Dispose method release serial port for another application. After disposal $LogStream$, $Port$ and $Name$ are the 
	only properties of $Epuck$ instance, which can be accessed. They can be used to reconnection, see above.

\subsection{Touching e-Pucks's sensors and actuators}\label{sec:touching}
	$ConsoleTestActuatorsTimeout$ function presents all actuators. Let us choose to control the motors of e-Puck.
\begin{lstlisting}[language=cs]
      ada.Motors(1,-1,
        (nth) => { Console.WriteLine("Motors(..) OK "); end = true; },
        (nth) => { Console.WriteLine("Motors(..) KO"); end = true; },
        null, myto);
      wait(0);
      ada.PlaySound(3,
      // ...and so on
\end{lstlisting}
	
	$Motors$ method control speed of wheels. See code above. Maximum forward speed is +1, backward speed -1. Both motors are controlled at once via first two parameters.
	Next two parameters are functions, which match $Okfactuators$ resp. $KofCallback$ delegates. Both delegates have only one $object$ parameter. In this example $null$ value is passed
	to the lambda function through fifth argument of $Motors$. Last parameter is the $timeout$, which tells $Epuck$ how long can wait to answer of $BTCom$ in seconds.
	First delegate is called called if the answer from $BTCom$ is confirmed before $timeout$ has elapsed. $KofCallback$ is called otherwise.
	$ConsoleTestActuatorsTimeout$ function wants to present reaction time of all commands, therefor it does not allow commands to called asynchrounously one after each other.
	Function $wait(0)$ ensures that force the current thread wait until answer is delivered or $timeout$ elapsed. Simple synchronization is done via $end$ flag.
\begin{lstlisting}[language=cs]
static void wait(int gap) {
      ///<remarks> Simple but unefficient way of waiting. See KofOkfWaiting(..) in Behaviour for usage of EventWaitHandle.</remarks>
      while (!end) { 
        Thread.Sleep(5); 
      } 
      end = false; 
      Console.WriteLine("Ended: {0}",Stamp.Get());
      Thread.Sleep(gap);
      Console.WriteLine("Start: {0}", Stamp.Get());
}
\end{lstlisting}

	$ConsoleAsynchronousSensors$ function asks for sensors too, but does use synchronous waiting only at the end. Run the example and explore huge gab
	between computer time after asynchronous calls and computer time after synchronization. The time is measured in seconds!
	
	Last function in the introductury section is $GetImage$ function. It present the only sensor, which return value was not presented.
	The function creates a window after an image is captured. The TestElib's application is blocked until the windows is opened. To see the picture from
	e-Puck's camera switch from the running TestElib's console to the new window.


\begin{lstlisting}[language=cs]
	IAsyncResult ar = e.BeginSetCam(40, 40, Zoom.Small, CamMode.Color, toSetCam, null, null);
        e.EndFtion(ar);
        ar = e.BeginGetImage(toImg, null, null);
        Bitmap bm = e.EndGetImage(ar);	
\end{lstlisting}


	$ShowImage$ uses an $IAsyncResult$ interface to set the camera and get the picture.
	Let us shortly introduce the interface on $BeginSetCam$ method, which called on instance $e$ of e-Puck.
	$IAsyncResult$ interface allows easily start asynchronous operation and after that easily wait on the the result.
	$BeginSetCam$ starts the asynchronous operation, which sends the relevant command, and $EndFtion$ waits to it.
	The $EndFtion$ can wait to $BeginSetCam$ result, because $ar$ $IAsyncResult$ instance was created in $BeginSetCam$.
	Every $IAsyncResult$ asynchronous function start with "Begin" prefix. 
	If it asks for a sensor value than it starts with "BegingGet" as you can see on $BeginGetImage$.
	$BeginGetInfoVersion$ and $BeginGetInfoHelp$ functions start with "BeginsInfo" prefix, their return values never change. The values are specific for version of $BTCom 1.1.3$ and
	are also available at $Epuck.BTComVersion$ and $Epuck.BTComHelp$ as static properties.

	The "End" function differs according the type, which is returning from its invocation.
	Sensors does return any value. Most of functions returns $int[]$ array. They start with "BeginGet" and then comes name of the sensor, 
	but $BeginGetImage$ returns a $Bitmap$ and the functions, which asks for BTCom's help and version,
	return $string$.
	$EndFtion$ can be applied on every Elib's $IAsyncResult's$ invocation. In other words $EndFtion$ can be used to wait on every "Begin" function, but
	it is not capable of returning values. Functions $EndGetFtion$, $EndGetImage$ and $EndInfoFtion$ returns relevant values, but
	these "Get" functions can be called only in pair with "Begin" functions, which ask for a sensor value of the same type as return value from "Get" function.

	An $IAsyncResult$ "Begin" function has always three arguments. If a function has more than three arguments, the obligatory arguments are the last.
	Let's look at $BeginSetCam's$ arguments. Widht and Height of image are first two parameters and together with zoom and colour is specific for $BeginSetCam$.
	Next comes $timeout$, which tells how long we are willing to wait to the answer. Instead of the $null$ values can be callback and its parameter of $object$ type specified.
	If we use $EndFtion(ar)$ we do not need callback.

	Callbacks are last notintroduced feature of $IAsyncResult$. They are depicted in next section devoted to simple behaviours of e-Puck robot.
\section{Behaviours} \label{behaviours}
	A behaviour is program, which control a robot. It can be described as an finite automaton, where transition from one state to another is based on sensor values.
	States represents actions, which robots performs.
	
	We presents behaviours invoked by functions $Bull$, $Billiard$, $GoAndTurn$,$Go2Light$ and $KofGoXcm$.
	$Bull$ behaviour act like a bull. If it sees red, robot attacks it. In $Billiard$ behaviour e-Pucks goes from obstacle to obstacle
	and if he is very near it turns around.
	$GoAndTurn$ let the robot drive a square of 15cm. There are another function like $goXcm$ or $turnAround$ available.
	All mentioned behaviours are implemented using $IAsyncResult$. 
	$KofGoXCm$ is the only one behaviour, which is implemented by using simple $Epuck's$ interface.
	It allows robot go almost exactly given amount of centimeters, even in if the connection breaks during the ride.
	All behaviour used  callbacks, because it is natural way how to switch between states of a behaviour.

	Callbacks of "Begin" functions from $IAsyncResult$ return $void$ and takes one $IAsyncResult$ instance.
	The $state$ parameter, which is passed to "Begin" function can be found in AsyncState property from $IAsyncResult$ argument.
	In figure ~\ref{safedis} is on 3. line invoked $BeginStop$ function with $EasyDisposal$ callback and $ada$ instance as parameter for callback.
	On 7. line of ~\ref{safedis} example is the $ada$ parameter extract from $IAsyncResult$ ar.
	If we use "BeginGet" function to get a sensor values, then the values are returned by "EndGetFtion" call on $ar$ as we can see
	on line below.

	Callbacks are called always after the the operation finish, therefore the $EndFion$ on $IAsyncResult$ does not wait.
	Furthermore no $EventWaitHandle$ is created, which results in better performance if we use callback.
	For information about how is this feature implemented see section ~\ref{sec:iasync}.

	Callbacks are invoked in separate threads, which brings comlications, if we invoked more than one behaviour
	from one function as we do in $Main$ function. Problem is that $Epuck$ instance gets 
	commands from completely different behaviours at one time.
	Luckily all behaviours in TestElib let the the thread with $Main$ function wait, until they are finished.
	After an end of one behaviour next is invoked.

	For implementing a single behaviour there is guidelide, which introduce how to avoid problems with ending a behaviour.
	It is very simple. It has to be called only one function with callbacks in each method and furthermore it has to be the last action.
	It allows you to use $Dispose$ method, 
	without worrying about accessing instance of $Epuck$  from different threads.
	See the code and mainly the comments in ~\ref{safedis} example. 
	We suggest to return to this example after explorint some of the behaviours after exploring some of the behaviours.
	All the behaviours use this attitude, but has to care of its ending, because they used from main. See second comment in $Main$ function from ~\ref{safedis}.
\begin{figure}[!hbp]	
\begin{lstlisting}[language=cs]
static int Main(){
	//some work, Epuck ada created
	ada.BeginGetIR(0.1, EasyDisposal,ada);
	// no code using ada is allowed after BeginStop call
}
static void EasyDisposal1(IAsyncResult ar){
        Epuck ada = (Epuck)ar.AsyncState;
	int[] irSensors = ada.EndGetFtion(ar);
	// synchronous work e.g to stop using EndFtion
	ar=ada.BeginStop(0.1, null, null);
	ada.EndFtion(ar);
	//asynchronous call has to be the last!
	ada.BeginPlaySound(4,SafeDispose, ada);
}
static void SafeDispose(IAsyncResult ar{
        Epuck ada = (Epuck)ar.AsyncState;
	ada.Dispose();
}
\end{lstlisting}
\caption{Safe disposal for single behaviour} \label{safedis}
\end{figure}

\subsection{$IAsyncResult$ Behaviours}\label{sec:iabehaviors}
	Let us finally introduce the $Bull$ behaviour.
	Running this behaviour e-Puck behaves like a bull and bumps into red obstacles.
	$Bull$ behaviour switches between three states. In first states it travel randomly. After a random time it switch to observation state.
	In observation state it shoots 4 images from four directions. If the images are red enough it switch to aggressive behaviour and goes to the red obstacle
	other ways it starts a random ride again.

	
	The start function firstly sets e-Puck's camera to desired settings then it invokes the behaviour.
	CountDown is a struct, which wraps the Epuck and number of rotation.

\begin{lstlisting}[language=cs]
public static void Bull(Epuck ada) {
        startBehaviour();
        try {
          IAsyncResult ar = ada.BeginSetCam(40,40, Zoom.Small, CamMode.Color, toSetCam, null, null);
          ada.EndFtion(ar);
          ada.BeginGetImage(0.5, searchAround, new CountDown(ada, 3));
          endBehaviour();
        } catch (ElibException e) {
          exceptionOccured_End("Exception was thrown in Bull(..)", e);
        }
}
\end{lstlisting}
	
	The behaviours run until user press a key. The waiting is performed in main thread. The $Bull$ behaviour as all other behaviours runs in worker threads.
	If an exception, which singnals undelivered command, is thrown, its message is written to console and the behaviour ends. 
	Explore code in $exceptionOccured\_End$ function too see more.

	See code below how is the behaviour ended in nice way. It is tricky part and is not necessary if you use implement one behaviour see Figure ~\ref{safedis}
	for safe ending of single behaviour.
	Important is that $statrtBehaviour$ is called at first of $Bull$ method and $endBehaviour$ is called on the last line.
\begin{lstlisting}[language=cs]
static void startBehaviour() {
        endf = false;
        endconfirmed = new EventWaitHandle(false, EventResetMode.ManualReset);
}
static void endBehaviour() {        
        //If you press an key, endf is set to true. ->
        //->All behaviour recursive functions look like: if(!endf){..body..}else endconfirmed.Set();
        Console.WriteLine("Press enter to quit..");
        //Behaviours are usually infinite loops, they run and run.
        Console.ReadLine();
        ///<remarks>Blocks invoking next function</remarks>
        endf = true;
        ///Wait on EventWaitHandle until currently running function is finished.
        endconfirmed.WaitOne((int)(1000 * (toReset + toImg + to)));
        //releasing EventWaitHandle
        endconfirmed.Close();
}
\end{lstlisting}

\subsection{$Bull's$ internals} \label{bull}
	The diagram ~\ref{pic:bull} shows the states of $Bull$.
	Three states are named after the functions, which control the robot. "GetStacked" state
	is a final state and it arises, if the e-Puck is surrounded with obstacles from front and from behind.
	The $searchAround$ procedure call itself 4 times if no red obstancle is in front of e-Puck.
	It uses struct $CountDown$ to count the number of rotation.
\input{bull.TpX}
	Aggresive behaviour tries to bump into red obstacles. If it finds out an obstacle not red enough, it
	starts searching again. After four 90 degrees rotations in $searchAround$ are made the $wander$ behaviour is switch on.
	From $wander$ state can the behaviour can switch back to $searchAround$ or it can ends stacked.
	Let us show how simple the $aggresive$ function can be.

\begin{lstlisting}[language=cs]
double redl = 0.2;
IAsyncResult ar = ada.BeginGetImage(toImg, null, null);
Bitmap a = ada.EndGetImage(ar);
howRed(a, out red, out dir);
if (red > redl) {
      ada.BeginMotors(0.4, 0.4, to, agressive, ada);
} else {
      ar = ada.BeginStop(to, null, null);
      ada.EndFtion(ar);
      ada.BeginGetImage(toImg, searchAround, new CountDown(ada, 3));
}
\end{lstlisting}
	
\subsection{Billiardball behaviour}\label{billiard}
	The behaviour is invoked by $Billiard$ function. The behaviour is rather simple.
	It goes to wall, before the it stops. Then the robot tries to compute the
	orientation of the wall it turns around to go in next direction and than it goes straight
	to next obstacle.
	The behaviour runs without ending until the e-Puck is surounded by obstacles.

	The $rebound$ function tries to compute the angle of rebound, but as well the simple $go2wall$ function
	implements a restart of the behaviour.
	Let us focus on this part. We will show it on $go2wall$ function in figure ~\ref{restart}

\begin{lstlisting}[language=cs]
static void go2wall(IAsyncResult ar) {
  //value to decide if an obstacle is near enough
  int frontLimit = 1000;  
  //does not throw ElibException
  Epuck ada = (Epuck)ar.AsyncState;
  try {
    //doesn't create EventWaitHandle because the action has already completed synchronously.
    //Can throw an TimeoutElibException
    int[] ir = ada.EndGetFtion(ar);    
    if (ir[0] + ir[7] > frontLimit)
      ada.BeginStop(to, rebound, ada);
    else {
      //Does not use EndFtion, it safes the EventWaitHandle. We suppose, that it succeeds now or in next rounds.
      ada.BeginMotors(0.2, 0.2, to, null, null);
      //The BeginGetIR command is enqueued in the same mommen as BeginMotors, therefor 2*to.
      ada.BeginGetIR(2 * to, go2wall, ada);
    }
  } catch (ElibException e) {
    Console.WriteLine("Billiard restarted in go2wall, because of exception:\n" + e.Message);
    Invokes go2wall function again. It needs to be invoked by BeginGetIR command, because it expects ar with IR values.
    ada.BeginGetIR(to, go2wall, ada);
  }
}
\end{lstlisting}
	The exception can be throw only on in call of $EndGetFtion$ on the beggining and 
	no action in body was done, so the function can be called again from catch block without problems.

	The problem of this implementation is the logic not the implementation. The restart of the $go2wall$ function
	does not solve the problem with slow delivery of IR sensors, it only tries and tries again until enter is pressed.
	The solution will be presented in next behaviours.

	Next interesting feature of this example is not calling the $EndFtion$ to wait until $BeginMotors$ is confirmed.
	We suppose that if the commands of $BeginGetIR$ sensors are delivered, than the $BeginMotors$ are delivered too.
	Futhermore only one command delivered is enough to go to next obstacle.

\subsection{Exact movement and $GoAndTurn$ behaviour} \label{sec:go}
	Exact movement is very strong feature of e-Puck. E-Puck uses two stepper motors,
	which allows you to travel exatly 10 cm. The deviation less than one milimiter.
	E-Puck has also encoders, which allows you to measure the distance of travel with the same resolution.
	On the other hand communication over Bluetooth brings problems, which are typical for common electric motors.
	Usual motors have an ineria and they do not stop immediatly and they do not reach the desired at once. The same problem is with 
	Elib and Bluetooth communication the commands have a delay.
	The Bluetooth communication cause no more usual problems of motors as left and right motors are not equaly strong and they
	turn slightly to a side. Common problem is also with a flat tire, because then one wheel has bigger perimeter than the other.
	The programer of e-Puck do not have to solve this problems due to good design of e-Puck.

	$GoAndTurn$ is the only behaviour, which does not runs in infinite loop. It just goes around a perimeter of squere with side
	of 15 cm. It is based on $goXmiliseconds$ function, which let the robot ride with given speed for specified time.
	Functions $TurnAround$ and $goXcm$ are simply built on $goXmiliseconds$. The $square$ function from $GoAndTurn$ behaviour
	simply combines the functions.
	Let us introduce $goXmiliseconds$ function.
\begin{figure}[!hbp]
\begin{lstlisting}
static void goXmiliseconds(Epuck e, double L, double R, int milisec, double addto) {
  int x = e.Working;
  if (x != 0)
    throw new ElibException("It would be extremely inaccurate, if commands are still waiting to be sent.");
  double st0 = Stamp.Get();
  IAsyncResult ar = e.BeginMotors(L, R, addto, null, null);
  //debugging
  AsyncResultNoResult pom = (AsyncResultNoResult)ar;
  //debugging
  pom.Name += "goXms";
  e.EndFtion(ar);
  double st1 = Stamp.Get();
  milisec -= (int)((st1 - st0) / 2);//heuristic
  Thread.Sleep(milisec);
  ar = e.BeginStop(addto, null, null);
  e.EndFtion(ar);
}
\end{lstlisting}
\caption{Function goXmiliseconds} \label{gox}
\end{figure}

	The function needs to have no queued commands in $Epuck$ instance, because it suppose that sending takes almost no time and any waiting makes it very unaccurate.
	The function sends the command to motors, then waits a given time and then stop.
	The idea behind the little heuristic is that every command sending takes the same time and also the commands transfer to e-Puck and from e-Puck is equally fast.

	More interestin feature presented here is extracting a $AsyncNoResult$ class from $IAsyncResult$ interface. For more information see ~\ref{sec:iasync} section.
	From user's point of view it is good to know, that $Name$ property can be changed. $Name$ property is used in logging. It's default value is the name of "Begin" function,
	which created the instance of $IAsyncResult$. The $Name$ attribute is feature of Elib and is not defined in $IAsyncResult$, therefore the cast is need for accessing it.

\subsection{Restarting $Go2light$ behaviour}\label{sec:go2light}
	Robot following the light is a typical robotic task. $Go2Light$ behaviour uses only one recursive function, which implements the behaviour.
	Following example also presents guideline how to cope with unreliable connection in infinite behaviour.

\begin{figure}[!hbp]
\begin{lstlisting}
	
static void recGotoLight(IAsyncResult ar) {
  Epuck ada = (Epuck)ar.AsyncState;
  try {
    ar = ada.BeginGetLight(to, null, null);
    int[] light = ada.EndGetFtion(ar);
    //..missing part
    if (diff_fb > 0) {
      if (light[2] < light[5]) {
	Console.WriteLine("turn around right {0}", diff_lr);
	ar = ada.BeginMotors(speed, 0, to, recGotoLight, ada);
      } else {
      //...missing part: the lighst is on front left, back right,...
    }
    //there is no need to repeat EndFtion in the branches
    ada.EndFtion(ar);
  } catch (TimeoutElibException) {
    exceptionOccured_Restart(ada);
  }
}
\end{lstlisting}
\caption{Function $recGotoLight$ function} \label{go2light}
\end{figure}
	The structure of $recGotoLight$ function is clear. Let us explore the interesting $exceptionOccured\_Restart$ function.
	The function end the session with real e-Puck and closes a serial port by calling the $Dispose$ method.
	After the disposal the commands can not be sent ot e-Puck and we have to create a new connection. We use the same parameters.
	Optionaly here is the place to ask the user of behaviour to change a port name.
	The same attitude is used in $KofGoXCm$, which will be presented later on.
\begin{figure}[!hbp]
\begin{lstlisting}
static void exceptionOccured_Restart(Epuck ada) {
        //Reconnect again to e-Puck
        ada.Dispose();
        ada = new Epuck(ada.Port, ada.Name);
        restarts--;
        if (restarts >= 0) {
          Console.WriteLine("Remaining " + restarts.ToString() + " restart. Press enter to continue");
          ada.BeginStop(to, recGotoLight, ada);
        } else {
          Console.WriteLine("End of Go2Light, because all " + restarts_startingValue.ToString() + " has been used.");
          Console.WriteLine("Behaviour has finished. Press enter to perform next actions");
        }
}
\end{lstlisting}
\caption{Function $exceptionOccured\_Restart$ function} \label{restart}
\end{figure}

\subsection{Behaviour with return implemented via $Epuck's$ basic interface}\label{sec:kofgoxcm}
	The behaviour is invoked by $KofGoXcm$ function. It a connection Bluetooth connection between e-Puck and a computer is unbroken.
	The robot goes specified amount of centimeters. If the connection breaks during the behaviour, the behaviour ask user to perform repair action to connection,
	but keep e-Puck running. If the connection is repaired successfully then e-Puck goes to the destionation, where it should have ended before the connectio failure.

	The behaviour  uses $Epuck's$ basic interface,	which has been introduced in section ~\ref{sec:touching}.
	It has some design consequences. The example has two implements in fact two behaviours. The behaviour, which has a good connection at disposal,
	and the behaviour, which has to deal with a broken connection.
	We also keep the quideline from ~\ref{safedis}. It says, that the asynchronous call should be called only once at the end of a function.
	It is necessary to aviod parallelism and problems with ending of the behaviour.
	In summary the amount of functions grows rapidly, because we can not easily synchronously wait to answers from e-Puck
	and furthermore we have to implement two attitudes.
	The implementation of is straightforward see the source code for more information.
	We will focused on a function, which is called to stop the e-Puck after it traveled the required distance.

	Let us remind the $Epuck$ basic interface.
	In ~\ref{stopKof} is used class $RobotAndTime$, which is also depicted with its basic members.
	As you can see the structure of the code does not differ a lot from $IAsyncResul$. Firstly the necessary cast is performed in order to 
	extract $RobotAndTime$ class, then the logic is implemented and at the end the commands to e-Puck are sent.
	The $Kof$ and $Okf$ commands use the same state argument for passing data e.g. $RobotAndTime$ instance. The state argument together 
	with timeout are obligatory and are located at the end of functions.
	If the $Okf$ callback for a sensor command has additional first argument of sensor type. For example
	the callback for $GetIR$ command looks like $void OkGetIR(int[] values, object state);$.
	
\begin{figure}[!hbp]
\begin{lstlisting}
static void stopKof(object robotAndTime) {
      Console.WriteLine("stopKof was called.");
      RobotAndTime x = (RobotAndTime)robotAndTime;
      x.stopKof++;
      if (x.stopKof > 5) {
        if (!reconnect(x))
          return;
        else
          x.stopKof = 0;
      }
      double time = Stamp.Get() - x.StartTime;
      if (travelled(time, x.Speed) < (x.Cm + 0.05))
        x.E.Stop(stopOkf, stopKof, x, to);
      else {
        Console.WriteLine("We passed the destination spot, we returns back, Try repair the connection.");
        x.Cm = travelled(x.StartTime, x.Speed) - x.Cm;
        x.Speed = -x.Speed;
        x.StartTime = Stamp.Get();
        x.E.Motors(x.Speed, x.Speed, goOkf, goKof, x, to);
      }
}
class RobotAndTime {
      // Lot of parts missing!! The thread.Safe read and write is missing!!
      public double StartTime;
      double cm;
      double speed;
      public volatile int stopKof = 0;
      public volatile int goKof = 0;
}

\end{lstlisting}
\caption{$Kof$ callback $stopKof$} \label{stopKof}
\end{figure}
	Interesting is the logic of this example. After five unsuccessfull attemps to stop the $reconnec$ function
	prompt user to repair the connection. If the user tell the behaviour to end no other function is invoked and the behaviour is ended.
	Otherwise the actions for going to desired place are executed.
	If the robot does not drive away too far, the $Stop$ function is called again.
	It has $stopKof$ function as its $Kof$ callback.
	If the robot travel too long than it has tu go in opposite direction, this is done in the second brach of the $if$ command.
\input{kofgoxcm.TpX}

%%todo processing the image 
\subsection{Logging of $Epuck$ actions and image processing}\label{sec:logging}
	In file $TipsAndTricks.cs$ is located a simple example of image processing after on a picture from e-Puck's camera.
	The example is invoke by $ShowProcessedImage$ function and it displays a window, where is a black and white processed image.
	The white is instead of a red colour and black represents the other colours. Nice test of this function is to place
	the e-Puck's box with the e-Puck logo in front of the camera. 

	The function $LoggingExample$ uses a function $ConsoleTestSensorsTimeout$, which has been presentd at the beginning of this section in ~\ref{sec:touching}.
	It runs the function twice, each time with different timeout. The logging to file specified in $name$ is turned on.
	Try to run the function. The call from $Main$ function $name$ with "Log" value.
	Lets see the body of the function.
\begin{lstlisting}
ada.LogStream = new StreamWriter(new FileStream(name, FileMode.OpenOrCreate, FileAccess.Write));
ada.StartLogging();
for (i = 0; i < 2; ++i) {
	double to=1.0 / (i + 1);
	ada.WriteToLogStream("ConsoleTestSensors with timeout :"+to.ToString());
	ConsoleTestSensorsTimeout(ada, to);
}
ada.StopLogging();
\end{lstlisting}
	Logging to a file is really simle. In needs only stream, where is the log written. 
	After the start of logging all actions, which send commands to e-Puck, performed on $ada$ instance of $Epuck$ are logged
	to file on path $name$.
	$WriteToLogStream$ method inserts a commented line to the log file.

\section{Elib tools (et)}\label{sec:et}
	Elib offers a standalone commad line application, which
	parses the log from. It is meant to be the base tool for a programmer,
	who wants to statisticly analyze a log from $Epuck$ class.

	Et can be used only from commandline and parse the log row by row.
	It reads the log file perform a choosen action and write the result to output file.
	If user does not specify the file it writes or read from resp. to comand line.
	Elib tools support three operation. Two of them are process the data only from a numeric values.
	First operation counts an average of selected column from a log file.
	Next operation sorts out rows, which has in specified column values in given range.
	Last implemented operation allows separate rows, which have in specified column a value from gived collection of words.
	Elib tools application skips the rows beginning with $'\#'$, which is in Elib by default a comment in log file.
	Let's look at the usage. The most important command is the second row, which invokes the help file.
	The help file introduce a comlete usage of et command.
	Let us remarks, that this invocation was performed in PowerShell on Windows. On Linux you need to add "mono" before every program,
	which was compiled for .Net or Mono.
\begin{verbatim}
>>et -s sourcelog.txt -d output.txt Avg 0
>>et -h
et (Elib Tools) HELP FILE
...here the help file continues
\end{verbatim}

\subsection*{Design of Elib Tools}
	The purpose of Elib Tools is to be simple tool for parsing log file from Elib.
	The application is written in order to be as robust as possible.
	The wrong arguments does not throw any exception, but the application does no action.

	The main contribution of Elib Tools application is its design, which can be easily extended.
	The application can be easily change according specific needs of a programmer.
	The programmer needs to modify $parseArguments$ argument function.
	As you can see the $parseArguments$ function returns only the pathes of source and destionation file
	and $Action$ object.
\begin{lstlisting}
Action action = parseArguments(args, out source, out destination);
\end{lstlisting}
	
	$Action$ object is an abstract class, which is introduced later on this section. It provides
	interface for performing operation to every row.
	If new functionality is added, it could be implemented only by deriving a class from $Action$ and by overriding
	two functions. Let us presented on example of Avg command. Lets look firstly at $Action$ class.
\begin{figure}[!hbp]
\begin{lstlisting}
abstract class Action {
    const string Comment = "#";
    protected int column;
    protected TextReader r;
    public TextReader R { get { return r; } set { r = value; } }
    protected TextWriter w;
    public TextWriter W { get { return w; } set { w = value; } }
    protected char[] sep;
    public char[] Separators { get { return sep; } set { sep = value; } }
    public Action(int Column) {
      column = Column;
    }
    public void DoAction() {
      string line = null;
      while ((line = r.ReadLine()) != null) {
        if (!line.StartsWith(Comment))
          LineAction(line);
      }
      LastAction();
    }
    protected virtual void LastAction() { /*usually does nothing and is called after all lines are processed*/}
    protected abstract void LineAction(string line);
  }
\end{lstlisting}

	Log from 
\caption{$Action$ abstract class for performing row operation}\label{action}
\end{figure}

	Now let us focused, on $Average$ class, which after instantiotion computes the average by calling a method $DoAction()$
	inherited from $Action$ class. 

\begin{figure}[!hbp]
\begin{lstlisting}
class Average : Action {
    long count;
    double avg;
    public Average(int Column)
      : base(Column) {
      count = 0;
      avg = 0;
    }
    protected override void LineAction(string line) {
      count++;
      avg *= (count - 1) / (double)count;
      try {
        avg += (Double.Parse((line.Split(sep)[column])) / count);
      } catch (FormatException e) {
        Console.WriteLine("Avg has to be done from Integer. Error: " + e.Message);
        avg = double.NaN;
      }
    }
    protected override void LastAction() {
      w.WriteLine("{0:F8}", avg);
    }
}
\end{lstlisting}
\caption{$Average$ class}\label{average}
\end{figure}

	$Average$ class computes average in every step in order too avoid overflow of a variable in parsing long input files. The overflow
	of a variable is postponed by computing average in every step from previous step, because the typical implementation
	by sum all the values and after then diving it with its amout leads to overflow the sum much more quickly.

\section{Purpose of Elib and its properties}
	In this chapter we have presented Elib and the guidelines, which is convinient to follow using Elib. 
	This section follows up to contents of the previous sections and introduce a view from,
	which was the Elib created.

	Elib library was designed in order too help students of mobile robotics	with controlling e-Puck by their programs.
	Elib extends the possibilities of e-Puck processor, which can perform a very limited range of algorithms
	due too its low performance.
	Moreover Elib provides a student with a lot of examples. The examples are densely commented
	and can be easily modified.
	On the other hand a programm, which use Elib, gives up of direct control over robot,
	which can be observed the best on $GoAndTurn$ behaviour in section ~\ref{sec:go}.

	We have presented a few of simple behaviours, which controls e-Puck, but much more can be done with Elib.
	Elib can be used easily for controlling more than one e-Puck at once by creating more sessions using
	diffent instances of $Epuck$ class. Programs, which are needs more than 8KB of memory on e-Puck such 
	as genetic programs or neural networks, can easily control e-Puck over Bluetooth.

	The real challenge is processing a picture from e-Puck, because the dsPic processor of e-Puck is not sufficiant
	and also Elib needs to wait quite a lot of time for a picture.
	On the other hand $Bull$ behaviour successfully use the camera to grab the picture
	and also a graphical application Elib Joystick shoots the pictures with a camera.

	Elib Joystick is a graphical application, which makes all sensors and actuators of e-Puck accessible on one window.
	It also supports capturing an image, which is presented enlaged to the user.
	The graphical application runs in Single Thread Appartment on Windows, which means that the controls of the window can 
	be access only from the main thread.
	In order to update the sensors Elib Joystick use either $EndFtion$ or a $Dispatcher$.
	$Dispatcher$ is a class, which allows access the controls from different thread. It is specific according the technology,
	which is used to run the graphical part of application. Elib Joystick uses Windows Presentation Foundation and
	uses a dispatcher to capturing image. The other operation, which has timeout 0.1 s, access the controls synchronously using
	either $EndFtion$ or $EndGetFtion$. See section ~\ref{sec:bull} for information about these functions.
	Elib Joystick is introduced in appendix ~\ref{app:joystick}.

	Elib can access all sensors of e-Puck. See the chapter ~\ref{sec:epuck} for more information about e-Puck's sensors and actuators.
	However the camera is not used in full resolution,
	because the e-Puck processor has no place, where to store the captured image.
	The Elib captures only the amplitude of sounds from e-Pucks mircrophones. The freqvency of a sound can be computed on dsPic processor
	using Fast Fourier Transformation, but the $BTCom 1.1.3$, which is used by Elib, does not supproted 

	To conclude Elib offers almost all sensors of e-Puck in full quality. It also controls all of e-Puck's actuators.
	Furthermore it offers much more comfort than a programming e-Puck's processor directly. Read section \ref{todo} about advantages
	of remote control. 
	Last but least the Elib can be used from all .Net languages including $C\#$, $Visual Basic$, $F\#$, which is a functional language of .Net based OCaml,
	or $Iron Python$, which is a .Net implementation of Python. On Mono runtime, which runs both on Linux and Windows, the $C\#$ language can be used.
	The Elib is compatible with .Net 2.0 and higher and with Mono 2.0 and higher.
	%todo references
