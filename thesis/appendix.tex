%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Installation guide of {\it Elib} library and its tools} \label{app:installelib}
	The following sections guide an user on his first step in e-Puck programming via {\it Elib}.
	First of all the requirements for running a sample $C\#$ program {\it TestElib} will be presented.
	Guide line how to explore and install the {\it TestElib} follows.
	The installation of {\it Elib} and {\it TestElib} differs according your operating system and runtime.
	The possibilities are Mono\cite{mono} and .Net runtimes. Mono runs on Linux as well as on Windows. Microsoft runtime .Net
	runs only under Windows, but supports also other languages than $C\#$ in contrast to Mono.

	The installation does register neither {\it Elib} nor {\it TestElib} into a operating system. It enables
	a simple copy instalation without a need of the administrator rights.
	\section{Requirements for running an e-Puck's first program}
	\label{sec:require}
	Let us suppose, that we have an e-Puck robot with {\it BTCom} 1.1.3 charged and equipped with default programmes.
	\footnote{\small{If you need download {\it BTCom} to e-Puck, follow the guide 
	\url{http://www.e-puck.org/index.php?option=com_remository&Itemid=71&func=fileinfo&id=16}.}}
	Let us start with turned off e-Puck. Turn e-Puck on.
	A green LED shines if the e-Puck is on and the battery is not empty.
	The low state of batery is signalled by a small red LED next to the green LED. 
	If the red diode is blinking or shining take off the batery and let it recharge.


	We need a Bluetooth device, because we want to send commands to e-Puck via Bluetooth. Install it and assure,
	that it is working.
	At last, we need the runtime, which is necessary to run a compiled $C\#$ programs. 
	{\it Elib} library, {\it TestElib} and {\it Elib Tools} require .Net 2.0 or a higher version of .Net under Windows.
	To run the mentioned programs under Linux use at least version 2.0 of Mono runtime.
	A graphical application {\it Elib Joystick} and simple console application Simulator
	run only under Windows and {\it Elib Joystick} needs .Net 3.5 or higher.

	All programs are aimed at programmers and therefore we recommend the following integrated development environments (IDE) ,
	which are serious benefits of $C\#$ programming.
	We published all programs in formats of a Microsoft Visual Studio 2008 solution or a MonoDevelop solution.  
	Microsoft Visual Studio 2008 (MSVS) and MonoDevelop 2.4 IDEs can be obtained freely for educational purposes.
	If at least one of the IDE is installed, all prerequisities are fulfilled to a comfort exploration of presented examples. 
	They substitute compiler, editor and debugger and save a lot of work.
	All following examples suppose, that MonoDevelop or MSVS is installed.

	Last but not least we have to check it the e-Puck's selector is at the right position.
	E-puck is deployed with {\it BTCom} downloaded to its michrochip. 
	The {\it BTCom} is saved under the second position of selector. 
	Turn selector directly to e-Puck's microphone, shift it twice to the left 
	in order to choose {\it BTCom} from default settings.

	Prepare {\it Elib} library for an installation.
	
	\section{copy installation} \label{sec:copy}
	Let us suppose that all preconditions from section ~\ref{sec:require} are met.
	Let us remind of the content of the {\it Elib} package.\\

	Both .Net and Mono technologies use a solution and projects files to group a source codes of applications.
	We placed the project and solution files together with the relevant source files in following folders:

	\begin{enumerate}
		\item Folder { \sf elib} folder contains a solution with {\it Elib} project and {\it TestElib} project.
			It contains {\it Elib} library project itself too.
		\item Folder { \sf testelib} folder contains only the project console {\it TestElib}, 
		which illustrates a typical applications of {\it Elib} library on sample programs.
		\item Folder { \sf et} folder contains solution and console project {\it Elib Tools}. 
		It allows process log files generated by programms,
		which use {\it Elib}.
		\item Folder { \sf joystick} hides a solution of a graphical application {\it Elib Joystick},
		which introduces e-Puck without programming. On the other hand, it shows
		how to build a Wpf application, which uses {\it Elib} and its multithreaded asynchronous model.
		\item { \sf simulator} folder contains a very simple windows console application Simulator and its solution. 
		Simulator requires VSPE emulator of serial port. Simulator
		 substitutes e-Puck by repeating constant answers. It allows to test your application without e-Puck.
	\end{enumerate}

	Most significant parts are located in the first three folders.
	{\it Elib Joystick's} crucial programming technique are described in Appendix ~\ref{app:joystick}.
	The only other purpose of {\it Elib Joystick} is to provide a toy, which can access e-Puck's sensors and actuators without no knowlegde of progamming.
	The Simulator application is on the other hand a simple tool for programmers, who profile their application for e-Puck for a better performance.
	See its code for instructions how to use it and modify it.

	The applications {\sf et}, {\sf {\it Elib Joystick}}, {\sf Simulator}, {\sf Elib} and {\sf {\it TestElib}}
	can be installed to your computer only by copying.
	If you are using MonoDevelop, choose folders with suffix "$\_monodev$". 
	Copy the appropriete folder to the desired location.
	In order to see the source files, build them and run them open the downloaded folder, select the solution file with suffix "$sln$" and open it with your IDE.
	Build the solution file in MSVS by pressing Ctrl + B and in MonoDevelop by pressing F7. 
	In order to run the program use Ctrl + F5 in both IDEs.
	{\it Elib Joystick} and {\it TestElib} applications use a serial port to a communication with e-Puck. 
	The serial port has to be configured before running the applications.

	In order to configure the serial port turn your Bluetooth device and e-Puck on. 
	The devices can be paired together using an operating system specific application 
	for example Bluetooth Places on Windows and Bluetooth Manager on Linux. 
	The applications creates a virtual serial port, but before connecting to the port
	the devices has to be paired.
	The process of pairing requires a four digit number, 
	which is the single number printed on e-Puck's body.
	After pairing the devices, connect to the serial port.
	The bluetooth application assigns a serial port name to the e-Puck robot. 
	On Windows the port name looks like 'COM3'. 
	Linux port name has similar format like '/dev/rfcomm1'.
	The digits at the ends of port names differs according to the situation.
	In order to achive successfully run of {\it Elib Joystick} or {\it TestElib} check
	whether the assigned port name match the port name used by {\it Elib Joystick} or {\it TestElib}.
	If the assigned port name differs from the port name used in {\it Elib Joystick}
	or in {\it TestElib} application, then replace the port name used in the applications by
	the new port name assigned by operating system.

	We believe, that all conditions for a successful use  of {\it Elib} has been presented. 
	Let us note, that the most problems are caused by the hardware.
	Assure that you switch both e-Puck and Bluetooth on. Take in mind, 
	that the red control for indicating e-Puck's low battery is not reliable,
	so we suggest fully charging the battery before the first use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{ZZZ10joystick.tex} %\chapter{{\it Elib Joystick}} \label{app:joystick}
\chapter{{\it Elib Joystick}} \label{app:joystick}
	{\it Elib Joystick} is a graphical application for controlling e-Puck via Bluetooth.
	It accesses all sensors and actuators of e-Puck and allows user to control e-Puck interactively.
	It is inspired by Epuck Monitor 
	\footnote{\small{Download at \url{http://www.gctronic.com/files/e-puckMonitor_2.0_code.rar}}},
	but it is written in $C\#$, and uses asynchronous model
	of {\it Elib} to be more responsive than Epuck Monitor.

	\section{User Guide} \label{sec:joyguide}
	{\it Elib Joystick} graphical user interface is very simple. The single window of {\it Elib Joystick} 
	is divided into several areas.
	See Figure ~\ref{pic:joystick_start}.
	\input{joystick_start.TpX}

	In the middle is a connection panel. The connection panel is the only panel, which 
	has actived controls after start up. To activate the rest of controls following actions are necessary to
	perform. At first pair e-Puck with your computer. Then connect the assigned virtual port with e-Puck.
	Fill the assigned port's name in text box above the "Connect" button and press
	the "Connect" button. After pressing the "Connect" button {\it Elib Joystick} is connected to e-Puck. 
	%todo proc anglicky nejde {\it Elib Joystick} connects to e-Puck?
	The rest of controls are immediately activated
	as soon as the {\it Elib Joystick} is connected to e-Puck.
	See ~\ref{sec:copy} guide for detail informations. 
	
	\input{joystick_log.TpX}
	The single function available in a non connected state
	is Open File Dialogue depicted on ~\ref{pic:joystick_log}.
	In the  Open File Dialogue can be specified the file, 
	where are logged all commands sent to e-Puck after the connection
	to e-Puck is established.

	In order to start using the application connect it to the right serial port and press the "Connect" button.
	Automatically the position of selector is retrieved and the session is established.

	At the beginning all sensors has an uninitialised value, which is represented as a question mark 
	in most cases.
	Press the relevant button for retrieving the sensors value, then the values are displayed in the nearest label.
	There are two exceptions. The first exception is the visualization of e-Puck's IR sensors. 
	The values of the IR sensors
	are represented as the blue levels under check boxes on 
	the perimeter of the virtual e-Puck.
	The second  exception is the captured picture, which is displayed enlarged on the right side after its delivery.

	If the connection is too slow or the connection is lost, the application
	is set to initial state. The e-Puck has to be reconnected in order to continue control the robot.

	Let us remark that checking the Refresh check box can cause the application to be a little unresponsive.	
	It is so, because the application waits on all values of sensors including an image synchronously.
	On the other hand, a capture and transfer of an image, which was invoked by pressing "Get Pic" button,
	is performed asynchronously. 
	We have implemented both variants in order to compare the different attitudes.

	
	\input{joystick_ko.TpX} %lost connection se zachycenym obrazkem a ruznymi hodnotami.
	In Figure ~\ref{pic:joystick_ko} is shown the MessageBox, which tells the user to reconnect the application
	in order to continue.

	The actuators of e-Puck can be controlled either by clicking on the appropriate button or check box. 
	Another	possibility is to choose a value from combo box.
	The last option is to specify the  convenient values to text boxes and press relevant $set$ button.

	If you want to change the session press the $Disconnect$ button, choose some another port and 
	press again "Connect" button or	just quit the application and restart it.

	\section{{\it Elib} usage in {\it Elib Joystick}}\label{sec:joystick_trick}
	{\it Elib Joystick} is a graphical application and does not use any sophisticated algorithms. 
	It also uses {\it Elib} really simply in most cases, but there is a crucial problem if the callbacks are used.

	In {\it Elib Joystick} we use callbacks to retrieve an image, because it can last a long time.
	Problems in a graphical application arise if a graphical interface is accessed by a thread different from
	the main thread, where a message loop of the graphical application is running. The problem is solved,
	if all functions use the same thread in the so called Single Thread Appartment(STA).

	{\it Elib Joystick} challenges this problem, because it presents a picture from e-Puck's camera, which is updated
	in $Label$ of {\it Elib Joystick's} window. The callback, which updates the image, runs in a different thread.
	The problem is solved by using a $Dispatcher$ class. $Dispatcher$ accepts functions, which updates
	the GUI from different threads and calls them on the main thread in order to maintain STA character
	of GUI. 

\begin{figure}[!hbp]
\begin{lstlisting}
//Ep is instance of e-Puck,
Ep.BeginGetImage(imgto,
  //the callback(lambda function), which is called after an image capture
  (ar) => {
    try {
      Bitmap bmp = Ep.EndGetImage(ar);
      //delegate, which enwrap the lambda function, which updates the GUI
      updateUIDelegate d = delegate {
      	//body of the callback, which updates the GUI
	pic.Source = Convert2BitmapSource(bmp,colorful);
      };
      //updating the GUI by passing the update GUI callback to guid Dispatcher
      guid.Invoke(DispatcherPriority.Normal,d);
    } catch (ElibException) {
      notConfirmedCommand(this);
    }
  }, 
  null);
\end{lstlisting}
\caption{Update of an image using $Dispatcher$}
\label{updispatcher}
\end{figure}


	The code snippets ~\ref{updispatcher} and ~\ref{upsynchronous} present usage of the $Dispatcher$ class and 
	synchronous implementation of GUI update. Synchronous update does not require the $Dispatcher$ class,
	because it is performed from main thread.

	The $guid$ $Dispatcher$ used in ~\ref{updispatcher} snippet is obtained from the main thread and
	allows the passed functions to access objects as if they are be called from the main thread.

\begin{figure}[!hbp]
\begin{lstlisting}
IAsyncResult ar = Ep.BeginGetImage(imgto, null, null);
Bitmap bmp = Ep.EndGetImage(ar);
//pic is a Label
pic.Source = Convert2BitmapSource(bmp,colorful);
\end{lstlisting}
\caption{Synchronous update of an image from the main thread.}
\label{upsynchronous}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{ZZZdox_elib.tex}%\label{app:epuckref}
\chapter{$Epuck$ class reference documentation} \label{app:epuckref}
This Appendix describes the most significant class of {\it Elib}, the $Epuck$ class,
and its methods and field members.
The hierarchy of exceptions, which can be thrown by $Epuck$ class, is also included
The complete reference documentation can be found on CD, which is enclosed
to this thesis.

\chapter*{$Epuck$ class}
\input{dox_epuckfce_and_exceptions}
\chapter*{Exceptions}
	{\it Elib} wraps exception, which can be thrown during its usage, in $ ElibException$ class.
	$ElibExceptions$ thrown during using of {\it Elib} can be caused by other exception.
	For example, an $System.TimeoutException$ is thrown if a program tries to connect to port, 
	which is already owned by another process.
	In {\it Elib} such situation can happens and {\it Elib} wraps this exception
	with $SerialPortException$, which is inherited from $ElibException$.
	The original $System.TimeoutException$ can be retrieved from $InnerException$ property.
	See Figure ~\ref{exceptionuse}.
\begin{figure}[!hbp]
\begin{lstlisting}
//in Elib all exception are caught like this exemplary exception
      try {
        throw new ApplicationException("My exemplary exception");
      } catch (ApplicationException e){
        throw new ElibException("Just an example", e);
      }
//........................................................................
      //retrieving original exception after catching the ElibException
      try {
        //...some functions which use Elib and 
	// which throws new ApplicationException("My examplary exception")
      } catch (ElibException e) {
        Console.WriteLine(e.InnerException.Message);
      }
\end{lstlisting}
\caption{How to retrieve the original exception?}
\label{exceptionuse}
\end{figure}
	In the example is shown how is every single exception wrapped and thrown again in {\it Elib}.
	There is also depicted a way how to extract the original exception.
	The code, which catch exceptions from {\it Elib} would print followint output:
\begin{verbatim}
	My examplary exception
\end{verbatim}

	The following snippet illustrates the structure of {\it Elib's} exceptions and
	introduces all inherited subclasses.
	The subclasses serves to differentiate the {\it Elib's} exceptions.
\begin{lstlisting}
// The ElibEception is thrown, if an unusual situation happends in Elib.
// It wraps all other exceptions, which are thrown from Elib
public class ElibException : Exception { 
	//Only constructors are implemented
}
// The TimeoutElibException is thrown if the "End" function implementing IAsyncResult was called 
// and indicates that the answer to command has not been delivered in time.
public class TimeoutElibException : ElibException { 
	//Only constructors are implemented
}
// If SerialPort throws any exception, than this exception wraps the original exception.
// After that the SerialPortException is thrown.
public class SerialPortException : ElibException {
	//Only constructors are implemented
}
// ArgsException is thrown if wrong arguments are passed to function in Elib.
public class ArgsException : ElibException {
	//Only constructors are implemented
}
// Thrown if command to e-Puck has nonsense values.
public class CommandArgsException : ArgsException {
	//Only constructors are implemented
}
// Thrown if session with e-Puck has not started or has already ended.
public class UnconnectedException : ElibException {
	//Only constructors are implemented
}

\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
