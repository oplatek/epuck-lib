	Elib is a $C\#$ asynchronous library for a remote control of robot. 
	The goal of library is to make easier developing programs for e-Puck.
	The library should offer exemplary programs, which can be easily modified to their first e-Puck programs.
	These chapter presents several topics, which influenced design of Elib.
	Examples on usage of $Epuck$ class and its interfaces are introduced is in next Chapter.

	At first place the possibilities of programming e-Puck are depicted.
	Next section covers the drawbacks and advantages of asynchronous remote control programming of e-Puck.
	Furthermore key features of Elib are presented together with crucial decisions, which
	lead to properties of Elib. 
	The features will be confronted by their alternatives and the differences will be discussed.

	After that the logic of main classes $Sercom$ and $Epuck$ are introduced. Following two parts 
	describe implementation either of $Sercom$ or $Epuck$ in detail. 
	In part devoted to $Sercom$ is main stress on design of Bluetooth communication processing.
	The implementation details of the two $Epuck's$ interfaces are the main topic of rest of this chapter. 

	Last subsection sum up qualities of interfaces implemented by $Epuck$ and $Sercom$ class.
	It is followed by presenting Elib's perfromance results.
\section{Approaches to e-Puck programming} \label{sec:approach}
	E-Puck is distributed with several programs in its flash memory. 
	Most of the programs implement simple behaviours, which introduce e-Puck sensors and actuators.
	There is a behaviour, which made e-Puck go to light. If another behaviour is running, e-Pucks
	reacts to clapping and it turns around to source of a clap. An interesting behaviour makes
	e-Puck cry, if its falling.
	 
	BTCom and e-Puck bootloader are also distributed on e-Puck, but belong to different classes of programs. 
	BTCom allows e-Puck to communicate with	other devices via Bluetooth.
	It defines a BTCom protocol, which works in two modes. Text mode accepts commands for
	all sensors and actuators except it does not allows take a picture with an e-Pucks camera. 
	The accepted commands and the sent answers are short text messages.
	On the other hand binary mode, which accepts bytes as messages,
	can send a picture from e-Puck, but it implements fewer commands
	then text mode, so it does not control all sensors and actuators. All answers are sent from e-Puck 
	in binary mode,	which save a space of a message.
	 
	Bootloader, officially called Tiny Bootloader%todo citation
	, is the only wired program on e-Puck. It downloads	other programs to e-Puck via Bluetooth. 
	Tiny Bootloader has its counterpart, a graphical PC application,
	which allows users easy download hex files to e-Puck.
	A hex file for e-Puck is compiled C program for e-Puck's dsPic microchip. 
	%todo citace http://en.wikipedia.org/wiki/Hex_file
	 
	All mentioned programs including Tiny Bootloader use C library, which interface the devices on e-Puck. 
	The library and the programs are published under open source licence at http://www.e-puck.org .%todo url

	 
	If e-Puck is turned on, e-Puck starts running one of downloaded program according a selector 
	position. E-Puck's selector switch is a located on the main board of e-Puck.
	If you want to run another program you have to switch selector to another position
	and hold a second a reset button on e-Puck.	Selected program is loaded from flash memory
	to RAM memory and immediately executed.	
	 
	Suppose there is correct C code for e-Puck's processor. What has to be done to run the program?
	Let us describe the procedure.
	Firstly it has to be compiled and linked. After that transformation to a hex file is necessary,
	because e-Pucks's dsPic is 16 bit processor. In next step turn your Bluetooth and e-Puck on. 
	Pair the robot and your computer. Enter the PIN, 
 	which is needed to pair the devices. 
	PIN is a number, which is on e-Pucks body.
	The OS opens a serial port for Bluetooth communication.
	Start Tiny Boatloader, select the hexfile and the opened port. Follow the instructions,
	which will tell you to press a reset button on e-Puck. Press it only for about a second.
	If you are lucky, the e-Puck starts running your program.
	Tiny Bootloader tells when the download finishes. Last thing to do is to reset e-Puck
	and the e-Puck is running your program.
	 
	Your program was written to e-Puck's flash memory according selector position.
	If a program had been saved under this selector position, it was overwritten by your program.
	 
	It seems complicated, but there is an another way. 
	Turn selector to position, under which is loaded BTCom, and press reset button.
	Now is BTCom running.  Pair your PC with e-Puck as described above and use the open port
	to control e-Puck.
	BTCom starts running in text mode, so its possible to use a terminal to communicate with e-Puck.
	E.g Hyperterminal on Windows. On Linux write directly to serial port using command line.
	A program can control e-Puck via BTCom protocol too, but it must processed the commands ant their replies.
	 
	Nice example of accessing sensors and actuators over Bluetooth is e-Puck Monitor\cite{monitor}. 
	E-Puck Monitor is an open source graphical application written in C++, which uses BTCom protocol. 
	It can send and process answers to every sensor and actuator.
	It presents values of all sensors on one screen. Actuators can be controlled by mouse or by inserting
	proper values into text boxes.
	E-puck Monitor's big drawback is its freezing. It is not responsible, because it waits synchronously to some answers.
	If a Bluetooth connection with e-Puck breaks or the answer is lost, the application stays unresponsive.
	Epuck Monitor source code is also available as open source from  http://www.e-puck.org. %todo url
	 
	Downloading a hex file to e-Puck's microchip and remote control over BTCom protocol are two alternatives
	of controlling e-Puck.
	 
	Using BTCom user do not have to download any file to e-Puck's microchip.
	It is great advantage, because the length of developing cycle of program to e-Puck's processor.
	The developing cycle consist of	writing a code, compiling it, loading it, debugging it and correcting it.
	In following section the drawbacks will be described in detail and it will be confronted with
	remote control.
\section{Profiting from remote control} \label{sec:remote}
	The applications, which use BTCom and its protocol, run a whole algorithm on PC and BTCom just 
	execute the commands and get the values from sensors. Imagine you have a library, which process the commands
	and their replies. Your program uses the library and just asks the library for sensor values and
	gives the library commands what to do. The life cycle of developing a program is still writing a code, compiling it, debugging and rewriting. Important is that downloading part is missing.
	 
	It is so important, because downloading a program to e-Puck takes the most time and is the most unreliable part except debugging.
	The quality of debugging also differs a lot between these two attitudes.
	 
	If a program is downloaded to e-Puck, there are only e-Puck actuators for a feedback.
	It is not much because if something goes wrong, it is impossible to say if the program stopped running,
	or e-Puck is waiting to sensors values, or battery is down however the indicator of battery shows or e-Puck just can not move.
	Discovering the problem, even if it is the low battery, takes one or two loops of loading and compiling the program.
	Downloading a program takes a long time. It could last even a couple of minutes. It drives a lot of people crazy.
	 
	On the other hand a developer has all variables under control. If he set the breakpoints
	right, the logic should not be damaged. Of course like in every interactive application
	the breakpoints damage the logic at a lot of places. 
	
	It is case it is clear, where the breakpoints should not be placed.
	The breakpoint damages the logic of application only if it is set between two commands,
	which first has sent a command and the second is waiting to it.
	 
	A programmer, which controls robot remotely, can of course debug with tools of his programming environment.
	He is able to use e-Puck's sensors too. Also his own logging program can be useful. 
	Furthermore other sensors connected to his computer could help.
	All this can be utilised, because a computer has usually much more resources than e-Puck has.
	 
	If remote control is used, it can be said that the intelligence 
	is located on a computer. However if you load a program with Tiny Bootloader the intelligence
	is located on e-Puck.
	 
	The resources are useful first of all for implementation of the program and not only for
	its debugging. E-Puck for example takes picture smaller than 3200 bytes, but it is still
	a lot of work for e-Puck for complicated image processing. It is faster to process the picture
	on a computer. Let us note, that implementing a neural network or even genetic algorithm on 8kB memory
	is very difficult.
\section{Design of BTCom program. What does it mean for Elib?}\label{sec:btcomdesign}
	 
	Let $A$ be a PC and $B$ be an e-Puck robot. $A$ controls $B$ over BTCom protocol. BTcom program located on $B$ 
	replies to all commands sent from $A$.
	BtCom is a mainly textual protocol, which is defined by BTCom program. The answer of BTCom always begins with the first letter of the relevant command.
	If the command requires some sensor values, the value is attached to the first letter and
	sent. Otherwise the first letter of command is sent back alone. Each answer ends by 
	$\backslash$r$\backslash$n escape sequence.
	List of all text commands available see below.
	\lstset{basicstyle=\small}
\begin{lstlisting}
"A"         Accelerometer
"B,#"       Body led 0=off 1=on 2=inverse
"C"         Selector position
"D,#,#"     Set motor speed left,right
"E"         Get motor speed left,right
"F,#"       Front led 0=off 1=on 2=inverse
"G"         IR receiver
"H"          Help
"I"         Get camera parameter
"J,#,#,#,#" Set camera parameter mode,width,heigth,zoom(1,4,8)
"K"         Calibrate proximity sensors
"L,#,#"     Led number,0=off 1=on 2=inverse
"N"         Proximity
"O"         Light sensors
"P,#,#"     Set motor position left,right
"Q"         Get motor position left,right
"R"         Reset e-puck
"S"         Stop e-puck and turn off leds
"T,#"       Play sound 1-5 else stop sound
"U"         Get microphone amplitude
"V"         Version of BTCom
\end{lstlisting}
	  
	  
	The answers of BTCom from $B$ allows $A$ to know that the sent command was received and
	executed. 
	 
	Two main questions, which effects design of Elib, arise from the BTCom structure.
	Should Elib limit the waiting time for an answer from $B$?
	How fast should Elib allow $A$ sending the commands to $B$?
	 
	At first let us stress, that sending commands from Elib does mean in the following paragraphs
	sending textual or binary commands
	using BTCom not calling any functions of Elib, which wrap the sending. 
	 
	It is necessary to understand, that not only executing a BTCom command, but also a transfer of a command and a transfer of
	reply take insignificant amount of time. The time is measured from a computer processor's point of view, because
	it is the processor, who is waiting to serial port, which is sending the message.
	 
	Back to the question how should Elib limit sending of the commands.
	As we have said sending commands takes a while and therefore sending is performed asynchronously. 
	Due to asynchronous sending, users do not have to wait to the end of sending previous command and
	can send next before the first command has finished.
	It leads to queueing the commandsin a serial port buffer. Unfortunately the serial port buffer is usually not 
	very large and can easily overflow. 
	This is the reason for implementation Elib's buffer, a queue, which saves the commands
	from overwriting each other in the buffer. 
	The queue allows sending command asynchronously without useless losses.
	 
	Is problem with sending finished? Not for e-Puck. If the commands were sent too fast,
	the input buffer would have the same problem, because e-Puck's processor does not keep up emptying e-Puck's
	input buffer. It would be flooded and and some commands would be overwritten, 
	so Elib has to check, if the Bluetooth is not able to send commands too fast for e-Puck
	and possibly slow down sending of commands.
	How fast can e-Puck receive commands? Experiments showed, that gaps between commands around 0.02 s are critical at best condition,
	because e-Puck proccess each answer immediatly as it picks it up from its input buffer.
	 
	Let us focus on how long Elib shoud wait to the answer.
	Clearly we have to wait more than is the minimum transfer time from a computer to e-Puck and also
	the transfer time of the answer.
	The times of answers are all almost identical for actuators and corresponds with times for sending commands.
	Sensors messages carries more data on the way back, therefore sending sensors answers takes longer.
	An extreme is a command for taking a picture. Sending command to e-Puck last about 0.02 s, but
	the answer needs more than 0.2 s for a transfer.
	 
	Waiting for the answers takes even longer time than sending a command,
	so the waiting is performed in Elib asynchronously too.
	 
	Due to asynchronous design we can afford to wait as long as we can. 
	Possible variability of waiting time force Elib to let the user decide how long
	 Elib waits for a command. Elib does not limit the waiting time from the bottom,
	because the convenient values differs according a state of a battery on e-Puck, a strength of Bluetooth device
	on a computer and many others factors. 
	
	In examples, which will be introduced in chapter ~\ref{chap:usage}, the waiting times are set to the bottom limit,
	which allows commands to be confirmed without no problems under good conditions.
	The waiting times for answers are in Elib called $timeouts$.
	 
	Let us sum up the facts. Sending of commands takes insignificant amount of time.
	Sending commands are queued, because otherwise they could be overwritten in buffer.
	Receiving an answer takes even more time than sending a command from computer.
	Because sending is a good idea to implement asynchronously, the more implementing receiving
	answers asynchronously is sensible.
	What means asynchronous implementation in case of Elib? What is done if the answer receives in time
	and what if not? These questions are answered in next section called Asynchronous programming model for Elib.
\section{ Asynchronous programming model (APM) for Elib library}\label{sec:apm}
	It was already mentioned, that asynchronous call of function is convenient if the
	classical synchronous call let the processor waiting for instance to a device.
	In e-Puck's case the device is serial port. 
	 
	Synchronous communication using BTCom 
	is implemented in $Epuck$ Monitor.\cite{monitor} It waits not only to send the command, but
	it also waits synchronously on answer.
	 
	Waiting for the answer is typical situation and is worth to do it asynchronously. Graphical 
	applications explicitly requires to stay responsive. If they are not responsible, they freezes like Epuck Monitor.
	On the other hand asynchronous programming is much more complicated than synchronous programming.
	The goal of Elib is to hide the complications of APM and offer an interface,
	which allows Elib perform sending and receiving messages asynchronously and
	which allows a programmer control e-Puck without unnecessary complications.
	 
	Elib has two main classes and two interfaces implemented.
	$Serom$ is a public class, which wraps serial communication.
	$Epuck$ class represents an instance of a e-Puck robot and uses $Sercom$ internally.
	The interface of $Sercom$ for sending commands takes a
	string for command, two functions, class object and an integer as arguments.
	The string specifies a type of command, the integer represent the $timeout$.
	First function is called if the answer is delivered in time.
	Both function is called if the $timeout$ elapsed and the answer has not arrived.
	Second functions also use the class object as their argument.  These described
	functions are in Elib described as $Okf$ and $Kof$ callbacks. The class object
	can be used to send information for the function, or to gain information from the called function.
	Callbacks are functions, which are called after some procedure has finished.

	$Epuck's$ commands have two interfaces. First is directly based on the interface of 
	$Secom's Write(..)$ function it only removes the string argument, which the functions
	implements implicitly.
	Let us call it a basic interface.
	Second interface of commands is based on the basic $Epuck's$ interface. 
	It also accepts $timeout$, an instance of object class and one callback, but it returns 
	an implementation of $IAsyncResult$ interface, which will be introduced later.
	Simpler interface logic	and it is also well known interface  are reseasons fro implementing the $IAsyncResult$ interface.
	The interface is used across different .Net libraries.

	\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
public class Sercom {
	public void Write(string command, RCallback okf, NRCallback kof,object state, double timeout) {
		//... the body of function
	}
}

public class Epuck {
	public void Stop(OkfActuators okf, NRCallback kof, object state, double timeout) {
		//example of interface directly based on BTCom's interface
	}
	public IAsyncResult BeginStop(double timeout, AsyncCallback callback, Object state) {
		//example of IAsyncResult interface implementation
	}
}
 
\end{lstlisting}
	\caption{Public methods of $Sercom$ and $Epuck$} \label{serep}
	\end{figure}
\section{$Sercom$ class}\label{sec:sercom}
	An instance of $Sercom$ allows to communicate a computer asynchronously with other devices
	over serial communication. It accepts textual commands and textual answers.
	Commands and answers are distinguish according its first letter.
	
	Every sent command waits until the answer arrives or its $timeout$ elapses.
	After that next command is sent. Let us is called this waiting a $handshaking$ hereafter.

	This implementation really automatic guarantee that the commands would not be sent too fast,
	because e-Puck must pick the command from its input buffer to reply to it.
	For the short answers under good conditions it is not a waste of time, because
	if the battery is full all confirmation of stop command arrives under 0.04 s from 10 attempts.

	$Handshaking$ solves the problem, which made us choose it as the best implementation.
	If e-Puck is performing an action according sent command or if it is sending answer to the command,
	it is not able to pick commands from its input buffer.

	E-Puck processes a received message in three steps. It picks the command from input buffer.
	It process the command and then reply with an answer.

	For commands with long sending or processing phase it means following consequence.
	If such command is sent, next commands has to wait longer time, because there is a
	danger of e-Puck's input buffer overflow.

	%todo ulehcit ctenarovi cteni, tezko citelne
	At the beginning of Elib development we thought about implementing both $handshaking$
	and $nonhandshaking$ sending.
	$Nonhandshaking$ sending does not wait to answer of previous command. It sends immediately, but 
	it has to ensure, that the input buffer does not overflow.
	Motivation for $nonhandshaking$ is to save time, which is spent on waiting to answers on commands.
	We have experienced, that it is a nontrivial task to set the correct gap values. The final observation is, that 
	$nonhandshaking$ sending es even slower than $handshaking$ sending, because the gaps between sent commands
	has to be set at maximum in order to avoid a failure under bad condition. 
	The gaps for $nonhandshaking$ mode has too be exorbitant %todo naddimenzovany
	, because it must not to let the input buffer of e-Puck overflow.

	Moreover $handshaking$ is more general
	and does not depend on BTCom implementation. BTCom improves the times of processing the answers.
	In $nonhandshaking$ mode it means change a table of values, which stores minimal gaps after each command.



	\subsection{Logical problems with commands confirmation}\label{sec:logical}
	In $nonhandshaking$ mode a lot of commands can be sent before the $timeout$ of the first elapses.
	Let us introduce a common situation, which cause a serious problem. 
	
	Let the sent commands be of one type. For example all the commands can control the front LED light.	
	The problem consist of unwanted postponing a call of $Kof$ callback. 
	Let us imagine, that the answer to first command
	is lost, but the second answer manage to be processed under $timeout$ of the first command.
	It means that $Okf$ callback is called and the user assumes, that everything is in order.
	Furthermore the problem can be postponed to the last command of the same type,
	because the reply to the second command can be substitute for the reply of the third command
	and so on.
	The commands can be different, although they are of the same type.
	The $Kof$ callback can be called on different command, because the first command can turn the front LED on 
	with message "F,1", however the last command can switch the front led off with "F,0" command and 
	the reply to both commands is "F$\backslash r\backslash n$.

	$Handshake$ mode does not suffer from calling wrong callback, however if the $Kof$ callback
	does not prevent the user program from sending the command for the same device again,
	the answer from previous command can substitute the answer from the second command.
	Solution for a callback is to paste a command of different a type, which will exclude the option
	of the interchange of the answers.

	A convenient tool of separation commands of same type is pasting the stop command between them.
	If the program is not sure, whether the robot is reacting to its commands, safe behaviour is to stop.
	If $Kof$ callback is called on stop command, sending the stop command again does not breaks the logic,
	because whichever answer confirms that e-Puck is stopped. More examples of implementing $Kof$ callbacks
	are described in ~\ref{chap:usage} chapter.
\subsection{Current and previous $Sercom$ implementation}\label{sec:versions}
	Current $Sercom$ implementation has only four public functions.
	The constructor, $Start$ method, $Disposee$ method and a public method $Write$. See its interface in figure ~\ref{serep}.	

	Previous versions of Elib in addition implemented public method for changing from $nonhandshake$ mode to 
	$handshake$ mode and vice versa.

	The reason for introducing the previous versions with $nonhandshake$ implementation is present 
	the inner implementation, which is not dependent on $handshaking$ and $nonhandshaking$.
	%todo opravit simpler formulation nepekna
	It has simpler design, but the resources demands increase rapidly, if a lot of commands are sent.
	Current implementation remains stable.
\subsection*{Previous version}\label{previous}
	In  figure ~\ref{pic:sercom_nohandshake} is presented schema of the inner implementation 
	from previous versions of Elib.
	It shows functions and objects, which are used for sending and receiving the messages.
	Some methods have $nonhandshaking$ and $handshaking$ versions.
	$Nonhadshaking$ methods, which are drawn in red	at figure ~\ref{pic:sercom_nohandshake}, implements the same logic as $handshaking$ methods except they allow send and receive more commands
	at once.

	\input{sercom_nohandshake.TpX}
	Sending a command starts with calling public method $Write$. In $Write$ is instance of $checker$ class created.
	$Checker$ stores the command name, $Okf$, $Kof$, a reference to $state$ object and references to $notSended$ 
	and $Sended$ queues.
	It also stores a boolean value $answered$, which indicates whether the answer has been already delivered or not.

	$Checker$ starts in $Write$ method a separate thread, in which check method sleeps for a $timeout$.
	After the $timeout$ expires a method in separate threads checks whether the answered has arrived
	by reading $answered$ value. If $answered$ is set to true, it means that $Okf$ callback has already been 
	called and nothing is done. In other case $Kof$ is called and $answered$ is set to $true$.

	Let us introduce methods, which sends and receive the command.
	$Send$ resp.  Method $hSend$ and $Receive$ resp. $hReceivve$ method run in worker threads. 
	Method $hSend$ dequeues instances of $checker$ class from $notSended$ queue and
	sends the commands as soon as possible. $hSend$ method waits until $hSended$ variable
	of previous command is set to $null$. Both methods move after sending the command the instance
	of $checker$ class from $notSended$ to $Sended$ resp. to $hSended$.

	$Sended$ is a queue of $checker$ objects, $hSended$ is a reference to $checker$ object. 
	
	\label{p:oneargument}
	$Receive$ method process the text messages from the serial port and if a whole command is received
	it finds the first relevant instance of  $checker$.
	The answer is passed as one of the arguments to $Okf$ function and the function is called.
	If there is no $checker$ instance, which carries the same type of command with received answer,
	the answer is thrown away.

	$Okf$ function has additional string arguments, because the answer can contain values from
	sensors, which the $Okf$ function uses.
	$Kof$ function has nothing to process, therefore it can use only one argument, which
	was passed by function, which passed command using $Write$ method.

	The $checker$ instance of each sent command is during its existance saved either in $notSended$ queue or in $Sended$ queue resp. in
	$hSended$ variable.
	After calling $Okf$ or $Kof$ function the $checker$ instance is removed either from $notSended$ queue
	or $Sended$ queue resp. $hSended$ variable. 

	Problem of this design are cumulating threads. For each command in $notSended$ queue there is 
	one thread sleeping in $check$ method. If the sending is slow, the commands and its $checker$ objects are queued in
	$notSended$. Threads are valuable system resources. 
	It can be sent and received more than 20 commands per second and the longest $timeout$ for 
	e-Puck reset has to be at least 1.5 s, more than 30 commands can be easily created.
	If the Elib is used improperly, for example thousand of commands are sent and its $timeout$ elapses
	in the same time, than thousand of threads is need. This design of Elib is inconvenient, because
	it use too much system resources.
\subsection*{Current $Sercom$}\label{sec:current}
	Current version abondaned the implementation of $nonhandshaking$ mode, 
	because of the problems with receiving answers described 
	in section ~\ref{sec:approach}.
	It also solves the problem with	a lot of threads. 
	
	Elib currently uses two working threads and implements only $handshake$ mode.
	One thread running in function $checkNS$ checks whether the $timeout$ of sent commands
	has not elapsed during waiting in $notSended$ queue. Second thread checks whether the sent command
	stored in $hshake\_sended$ has a valid $timeout$ or the $timeout$ already elapsed.
	$Send$ calls asynchronously $AsyncSend$ procedure, which dequeues $ansGuard$ from $notSended$ queue.
	A class $ansGuard$ is a wrapper of commands like $checker$ in older versions and it will be presented below.
	Answers is also read asynchronously in $DataReceived$.

	Both methods $Send$ and $DataReceived$ use so called .Net asynchronous
	delegate invocation. It enables simple asynchronous invocation using a minimum resources.

	Let us brifely describe an instance of $ThreadPool$ class, which is created at 
	start of the application. It prevents from useless thread creation. The class keep the threads after 
	a function finish. The threads switch between different functions, which are called 
	by asynchronous delegate invocation.
	
	$ThreadPool$ use a delegate to invoke the function
	Delegate is a .Net strictly typed wrapper for function instance. \cite{delegate}
	See example of asynchronous function invocation using .Net delegate in figure ~\ref{deleg}.
	
\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
delegate void SendAsync();//fits function from returning void and which has no args	
void Send(object Sender, EventArgs ev) {
	SendAsync asyncCaller = new SendAsync(SendAsyncCall);
	asyncCaller.BeginInvoke(null, null);      
}
\end{lstlisting}
\caption{Example of Asynchronous function invocation}\label{deleg}
\end{figure}


	$Sercom$ inner structure is based on structure from previous versions, although
	different attitude is used to send commands, receive answers and check $timeouts$.
	All commands are wrapped by $ansGuard$ class. Instance of $ansGuard$ is created in $Write$ method.
	Into $ansGuard$ are stored callbacks and its optional argument $state$.  $Timeout$ is added to actual time
	in $Write$ method and stored to $ansGuard$, which is immediately enqueued in $notSended$ queue.
	In $notSended$ queue is a built in event $NonEmpty$, which calls $Send$ method, whenever something is written
	to $Sercom$ by $Write$ method. $Sent$ method is also called, if the $hshake\_sended$ variable is set to $null$.
	$Send$ method just calls $SendAsyncCall$. See ~\ref{deleg} schema.

	How is possible that $SendAsyncCall$ implements $handshaking$ mode?
	$SendAsyncCall$ actually does not send anything. It checks whether the command is received only if the $hshake\_sended$
	variable is set to $null$ and if $notSended$ queue is non empty. If $hshake\_sended$ is set to $null$ and $notSended$ queue
	contains some $ansGuard$, then $SendAsyncCall$ moves $ansGuard$ from $notSended$ to $hshake\_sended$
	queue and sends the command. 
	\input{sercom_handshake.TpX}
	
	The answers of $Sercom$ are processed in $Read$ fucntion,
	which is the DataReceived handler of .Net $SerialPort$. DataReceived handler is called asynchronously
	in .Net implementation of $SerialPort$ class if at least one new character is deliver to
	serial port input buffer. 

	$Read$ method, which is called asynchronously, just calls $textModeCall$
	in text mode and $binaryModeRead$ in binary mode.
	Only command, which is sent in binary mode in Elib, is command to get a picture.
	The picture is the only binary answer of $BTCom$ too.
	Description of $binaryModeRead$ is postponed to in following paragraph after a 
	$textModeCall$ method introduction.
	
	Every time the $textModeCall$ is raised, the new characters are step by step
	added to $ans$ container. If the whole answer is stored in $ans$, $ans$ is cleared.
	The found $answer$ is checked against $ansGuard$ stored in $hshake\_sended$.
	If it mathces, the $Okf$ callback is called and to $hshake\_sended$ variable is stored $null$. 
	Also $Send$ function is called via $Received$ delegate. If the answer does not match, it is thrown away. 
	
	If the binary mode is on, the $binaryModeRead$ procedure is called from
	$Read$ function. The $binaryModeRead$ does not read bytes step by step.
	At first it reads first three bytes, where width, height and mode of picture is stored.
	From the first three bytes is the amount of the rest bytes computed and then
	the function try to read the bytes all at once.
	If the picture is transferred before the $timeout$ elapsed, then the $Okf$ callback is called.
	The $Kof$ callback is called otherwise. The $Kof$ callback is the only $Kof$ callback,
	which has the answer at disposal, so the picture is passed to $Kof$ callback too.

	After $Kof$ or $Okf$ call in binary mode instance of $ansGuard$ is removed from $hshake\_sended$ and $Send$ method is invoked
	using $Received$ event.
	The last action of $binaryModeRead$ is switch the flag from binary mode to text mode.
	
	The BTCom switches back to text mode automaticly, because
	the "get picture" command is sent in binary mode to e-Puck together with empty byte, which
	switch $BTCom$ on e-Puck  immediatly after sending the picture back to text mode.


	Introduced implementation of sending and receiving commands and replies works well 
	until an answer is lost. $Timeouts$ ensure that, the $ansGuard$ stacked either in $notSended$ queue
	or in $hshake\_sendeded$, are cleared after its $timeout$  elapses. Both methods,
	which implements the removal an $ansGuard$, run in worker threads and also implements
	sophisticated system of waking and putting to a sleep, which prevents the threads from wasting
	the CPU time during their waiting to $timeout$ expiration. 
	The $checkSD$ function looks after the the $ansGuard$ in $hshake\_sended$ and $checkNS$ function guards
	the $ansGuards$ in $notSended$ queue.

	Putting the functions into sleep is complicated, because the $ansGuard$ has to be moved or deleted thread safely,
	which means synchronization primitives has to be used multiple times.
	
	%todoooooo todo todddddddddddddddddddddooo vysvetlit proc pri atomizovani se to muze zablokovat a proc jsou 
	%potreba dva EventWaitHandle
	
	Problems of $Sercom's$ inner structure has been depicted. For details of 
	$Sercom$ implementation see the code and the reference documentation.
	Let  us present the interface of $Sercom$ and its public members.
	

\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
public class Sercom:IDisposable{
	public void Write(string command, RCallback okf, NRCallback kof,object state, double timeout);
	public void Start();
	public Sercom(string portName, int serialPortWriteTimeout, int serialPortReadTimeout);
	public Sercom(string portName) : //with default constants
	      this(portName, defWriteTimeout, defReadTimeout) { }
	public int NotAnswered{get;}
	public int NotSended{get;}
	public byte[] LastImgBytes{get;}
	public bool FullImgBytes{get:}
	public int ModeImg{public get:}
	public int HeightImg{public get;}
	public int WidthImg{public get;}
	public void Dispose();
}
\end{lstlisting}
\caption{Public functions of $Sercom$} \label{publicser}	
\end{figure}

	$Write$ function has been already introduced. $Write$ can be used only
	after $Start$ function is called. $Start$ is called only once and it opens serial port and initialize
	the BTCom communication. Serial port is opened with parameters set in constructor of $Sercom$ or with
	default parameters speciefied in $Sercom$ like constants. $Dispose$ method close serial port
	and prepare $Sercom$ for garbage collection.

	There are also several properties available. $NotAnswered$ and $NotSended$ properties
	show how much is $Sercom$ class occupied. $NotSended$ returns only the lenght of $notSended$. $NotAnswered$ is at most by one greater than $NotAnswered$,
	because it returns number of $ansGuards$ in $notSended$ plus one if is an $ansGuard$ in $hshake\_sended$.
	

	Rest of properties are atributes of last taken image, if the $FullImgBytes$ is set to true.
	Otherwise the properties are not all from last image.
	If the $Okf$ was called on last taken image the $FullImgBytes$ is always $true$. The property
	comes in use if the $Kof$ callback was called, because it can be called from $notSended$ queue 
	or the bytes of image got lost. From width, height, mode and bytes can be built a bitmap, which
	makes $Epuck$ class.
\section{$Epuck$ class} \label{sec:epuck}
	Instance of $Epuck$ offers a virtual representation of e-Puck,
	which intermediate all sensors and actuators of e-Puck and which hides Bluetooth communication
	as much as possible.

	$Epuck$ use $Sercom$ internally and makes controlling of robot much more confortable.
	$Sercom$ treats only command "get picture" specialy, because it is the only one command in binary mode
	and has big time requirements. $Sercom$ does not differentiate between other commands.
	$Epuck$ differentiate between commands a lot. It tights $Epuck$ with concrete implementation of $BTCom$,
	but also it allows processed the answers and offer typing of returning values, which increases
	applicability. Main goal of $Epuck$ class is to offer a good interface.

	In these chapter the usage of $Sercom$ in $Epuck's$ methods is presented together with additional classes
	for implementation the interfaces. The reasons, which lead to implementing two independent interfaces for
	controlling e-Puck robot through $Epuck$ class, are presented.
	Least but not the last the used technology of .Net is mentioned.

	The $Epuck$ class brings nothing more than interface and debugging tools, which are best introduced
	on examples. There are several examples in these chapter. The usage of $Epuck$ class and the debugging
	tools is topic of next chapter. If you want to see more examples, look at chapter 6.
	This chapter presents the internalls of $Epuck's$ functions.
	
\subsection{Typed functions with $Okf$ and $Kof$ callbacks} \label{sec:okfkofi}
	$Epuck$ first interface just wraps the $Sercom$ class. It differentiates between
	commands for actuators, sensors with string return value and sensors, which returns an array of integers.
	$Epuck$ treats picture differently too, because it pass to callback a $Bitmap$ instance.


\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
public class Epuck{
	public void Stop(OkfActuators okf, NRCallback kof, object state, double timeout) {
		actuators(Commands.c_Stop(),okf,kof, state, timeout, "Stop(..)");
	}
	public void GetIR(IntSensorsOk okf, NRCallback kof, object state, double timeout) {
		IntArrSensors(Commands.c_Proximity(),8,okf,kof,state,timeout,"GetIR(..)");
	}
	public void GetBTComVersion(StringSensorsOk okf, NRCallback kof, object state, double timeout) {
		StringSensors(Commands.c_Version(), okf, kof, state, timeout, "BTComVersion(..)");
	}
	public void GetPicture(CamSensor okf, CamSensor kof, object state, double timeout) {
		checkArgs(okf, kof, timeout);
		logf(Action.call, f_name);
		ser.Write(Commands.c_GetImage(),
		(ans, data) => {
		  okf(parsingBitmap(ser.LastImgBytes, ser.WidthImg, ser.HeightImg, ser.ModeImg), data);
		  logf(Action.ok, f_name);
		},
		(data) => {
		  if (ser.FullImgBytes)//a whole img was captured
		    kof(parsingBitmap(ser.LastImgBytes, ser.WidthImg, ser.HeightImg, ser.ModeImg), data);
		  else
		    kof(null, data);//img is demaged
		  logf(Action.ko, fname);
		},
		state,timeout);		
	}	   
}
\end{lstlisting}
\caption{Four types of $Epuck$ control functions}
\label{publicep}	
\end{figure}

	Although there are four kinds of commands, the implementation differs only in processing the answer.
	The functions $actuatos$, $IntArrSensors$, $StringSensors$ all looks like $GetPicture$ method.
	
	There are only two differences between $GetPicture$ and other functions.
	Other function have to parse the answer in $Okf$ differently and they do not parse
	answer in $Kof$ callback at all.

	$GetPicture$ calls on answer $processBitmap$.
	The function $actuators$ throws away the string answer, because there is no information.
	THe $StringSensors$ method just calls $Okf$ with the string answer.
	$IntArrSensors$ parse the string answer and calls $Okf$ with an $int$ array argument.

	Second difference is that $GetPicture$ $Kof$ gets the answer. Others $Kof$ callbacks have
	only one parameter $data$, because there is no answer available in the moment of calling $Kof$.
	See paragraph ~\ref{p:oneargument} for more information.

	The difference of the functions is expressed by usage different
	delegates for $Okf$. $Kof$ functions use the same delegate. Only $GetPicture$ function has to 
	define its own delegate for image $Kof$.

	As you can see in Figure ~\ref{publicep} the callbacks, instead of passing $Okf$ and $Kof$  directly to 
	$Sercom.Write$ function, are wrapped in lambda functions \cite{lambda}.
	$Okf$ and $Kof$  callled within the lambda functions.
	The lambda functions allows logging and parsing the answers.

	A function $checkArgs$ at the beginning of $GetPicture$ does not allow to pass unsane arguments
	to $Epuck$ functions. $Timeout$ has to be a positive $double$ value, $Okf$ and $Kof$ has to be defined
	and not set to $null$.

	$Okf$ callbacks should be used for implementing the desired algorithm by Elib user.
	On the other hand $Kof$ callbacks should perform repair actions in order to get into valid state,
	where the algorithm can be restarted. A programmer, which uses Elib should always have in mind,
	that $Kof$ callbacks can be raised very often for low $timeouts$,
	but the call of $Kof$ callback signalizes a serious error state.
	See  section 6.1? for more examples of how to use $Okf$ and $Kof$ callbacks.


\subsection{$IAsyncResult$ interface} \label{sec:iasync}
	Two callbacks and schizophrenic logic of $Okf$ and $Kof$ implementation is not
	convenient for exploring e-Pucks sensors and actuators, 
	however it allows e-Puck to recover from every situation.

	Motivation for implementing the $IAsyncResult$ was its clear usage and its proven usability.
	See chapter 6 for $IAsyncResult$ introduction and examples.
	\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
IAsyncResult ar = ada.BeginGetIR(timeout, callback, state);            
int[] IRSensors = ada.EndGetFtion(ar); //if callback == null
\end{lstlisting}
	\caption{Usage of $IAsyncResult$}\label{arexample}
	\end{figure}

	The $IAsyncResult$ is introduced on example from ~\ref{arexample}, which uses $ada$ instance
	of $Epuck$ to made real e-Puck stop. The $timeout$ is the only parameter of $BeginGetIR$,
	which has nothing to do with $IAsyncResult$ interface, but it is need for its implementation.
	The requirements of interface is shown below in Figure ~\ref{interface}
	\begin{figure}[!hbp]
\begin{lstlisting}[language=cs]
interface IAsyncResult{
	public Object AsyncState { get; }
	public Boolean CompletedSynchronously{get; } 
	public WaitHandle AsyncWaitHandle { get; }
	public Boolean IsCompleted { get; }
	
}
\end{lstlisting}
	\caption{$IAsyncResult$ interface}\label{interface}
	\end{figure}

	Asynchronous operation implemented by $IAsyncResult$ needs two functions. One usually starts with 
	"Begin" prefix and the second starts with "End" prefix. This convention is strictly respected in Elib.

	$BeginGetIR$ is example of the first function and $EndGetFtion$ of the second function.
	$BeginGetIR$ takes three arguments. Most important is the $callback$ argument, which determine
	the usage of $IAsyncResult$ interface.

	If the $callback$ is null, than we need the second row of example and $EndGetFtion(ar)$ function
	in order to be sure that the real e-Puck has stopped.
	The call of $EndStop$ function blocks the current thread and waits synchronously until the real
	e-Puck is stopped.

	If the $callback$ function is defined, it is raised after the $BeginGetIR$ function has finished.
	Usually if $callback$ is used, than "End" function invocation is not necessary.

	The only posibility of $IAsyncResult$ interface to signal an error is raising an exception.
	The exception is passed to callback or the "End" function raises it.

	$IAsyncResult$ object $ar$ allows the $EndGetFtion$ to waits to the end of $BeginGetIR$ function.
	It is also used for passing to $callback$ user defined data in $state$ object.
	Another important feature of $ar$ is, that it allows $EndGetFtion$ function receive the data
	from $ar$.
	
	However $IAsyncResult$ is widely used trough .Net, it is an asynchronous programming model
	and is a bit tricky in some situation. See various examples in next chapter or on the internet 
	to get used to it.
\subsection{IAsyncResult Implementation} \label{sec:iasyncimpl}
	Jeffrey Richter made a nice example \cite{IAsync} of two classes, which implements $IAsyncResult$ interface.
	I used his classes and modified them according Elib's needs.
	First class is $AsyncNoResult$ and implements $IAsyncResult$ for actuators.
	Second class is generic $AsyncResult<T>$ subclass of $AsyncNoResult$ and it implements $IAsyncResult$ interface for sensors.
	Generic class mean, that the types of the result is chosen at compile time. %todo find definition
	Instaces of $AsyncResult<T>$ are used
	for answers of different type with different generic parameter $T$.

	
	The idea of $IAsyncResult$ interface is, that a programmer do not have to know, which
	class implements the $IAsyncResult$. They use $IAsyncResult$ type in code. See Figure ~\ref{arexample}. 
	On the other hand functions $BeginGetIR$ and $EndGetFtion$ has to know the type, which is passed to $IAsyncResult$ object.
	"Begin" function in Elib creates the instances $AsyncNoResult$ for actuators and $AsyncResults<T>$ for sensors.
	"End" function in Elib waits until the end of "Begin" function and throw an exception if the command has not been delivered in time.
	If the answer is delivered in time and if the command requested for a sensor value, the "End" function returns the desired answer of the sensor.
	
\subsection*{Obligatory members of $IAsyncResult$} \label{sec:iasyncmemb}
	Let us examine in detail the $IAsyncResult$ interface from figure ~\ref{inteface}. 
	$AsyncState$ is an object used as argument for callback function, which
	is passed to "Begin" function. If callback is not passed, the $AsyncState$ is not used. 
	$AsyncState$ is usefull for passing information to callback.
	$AsyncWaitHandle$ is a synchronization primitive, which allows waiting until the operation 
	started in "Begin" function is done.
	It waits synchro1nously. $AsyncWaitHandle$ is used in "End" function if the "End" function is called 
	and the operation is still running. Flag $CompletedSynchronously$ tells whether  
	$AsyncWaitHandle$ has been used to wait to the end of the operation.
	$CompletedSynchronously$ is always set to false if callback is used.
	$IsCompleted$ tells whether the operation from "Begin" function terminated or not.

\subsection*{"Begin" and "End" functions} \label{sec:beginend}
	Let us describe public methods of $AsyncNoResult$, which are used to implement "Begin" and "End" functions.
	$IAsyncResult's$ properties are not enough to implement $BeginGetIR$,
	$EndGetFtion$ or any other "Begin" and "End" functions.
	$BeginGetIR$ method use constructor of $AsyncNoResult$. It also uses $SetAsCompleted$ function 
	and $EndInvoke$ function both from $AsyncResult$ subclass.
	We will explain interesting and crucial part of both classes. 
	For implementation details see code in figure ~\ref{result} and ~\ref{noresult}.

	A constructor of $AsyncNoResult$ only sets the field members, 
	which are not changing during $AsyncNoResult$ existence.
	Implementation $SetAsCompleted$ function from $AsyncNoResult$ sets an exception to $AsyncNoResult$.
	Implementation $SetAsCompleted$ method from $AsyncResult$ overloads $SetAsCompleted$ 
	from its base class $AsyncNoResult$
	and adds a possibility to set the results instead of the exception.
	Third overload is implemented in $AsyncResult$ in order to GetPicture command can set both, 
	exception and result, at one time.
	$EndInvoke$ is called from "End" function and does all its logic. It checks whether the called 
	operation has finished.	If the operation is still pending, it sets up a new $EventWaitHandle$ 
	and waits completes. At the end it throws an exception if one has been set up, 
	or it returns a result if $EndInvoke$ from $AsyncResult$ was called.

\begin{figure}[!hbp]	
\begin{lstlisting}[language=cs]
public class AsyncResultNoResult : IAsyncResult {
	// Fields set at construction which never change 
	readonly AsyncCallback m_AsyncCallback;
	readonly Object m_AsyncState;
	// Fields which do change after operation completes
	const Int32 c_sp = 0;//StatePending
	const Int32 c_scs= 1;// StateCompletedSynchronously
	const Int32 c_sca = 2;//StateCompletedAsynchronously
	Int32 m_CompletedState = c_sp;
	// Field that may or may not get set depending on usage
	ManualResetEvent m_AsyncWaitHandle;
	// Fields set when operation completes
	Exception m_exception;
	// Name makes debugging easier in Elib. It shows, which command was used.
	string name;
	public string Name { 
		get { return (name != null) ? name : ""; } 
		set { name = value; 		} 
	}
	public AsyncResultNoResult(AsyncCallback asyncCallback, Object state, string name_) {
		m_AsyncCallback = asyncCallback;
		m_AsyncState = state;
		name = name_;
	}
	public AsyncResultNoResult(AsyncCallback asyncCallback, Object state) : 
		this(asyncCallback, state, null) { }
	public void SetAsCompleted(Exception exception, Boolean completedSynchronously) {
		// Passing null for exception means no error occurred. 
		// This is the common case
		m_exception = exception;
		// The m_CompletedState field MUST be set prior calling the callback
		Int32 prevState = Interlocked.Exchange(ref m_CompletedState, 
			completedSynchronously ? c_scs : c_sca);
		if (prevState != c_sp)
			throw new InvalidOperationException("You can set a result only once");
		// If the event exists, set it
		if (m_AsyncWaitHandle != null) m_AsyncWaitHandle.Set();
		// If a callback method was set, call it
		if (m_AsyncCallback != null) m_AsyncCallback(this);
	}
	public void EndInvoke() {
		// This method assumes that only 1 thread calls EndInvoke 
		// for this object
		if (!IsCompleted) {
			// If the operation isn't done, wait for it
			AsyncWaitHandle.WaitOne();
			AsyncWaitHandle.Close();
			m_AsyncWaitHandle = null;  // Allow early GC
		}      
		// Operation is done: if an exception occured, throw it
		if (m_exception != null) throw m_exception;
	}

	//region Implementation of IAsyncResult
	public Object AsyncState { get { return m_AsyncState; } }
	public Boolean CompletedSynchronously{get { 
		return Thread.VolatileRead(ref m_CompletedState) ==  ic_scs; }}
	public WaitHandle AsyncWaitHandle {
	    get {
		if (m_AsyncWaitHandle == null) {
		  Boolean done = IsCompleted;
		  ManualResetEvent mre = new ManualResetEvent(done);
		  if (Interlocked.CompareExchange(ref m_AsyncWaitHandle,
		     mre, null) != null) {
		    // Another thread created this object's event; dispose 
		    // the event we just created
		    mre.Close();
		  } else {
		    if (!done && IsCompleted) {
		      // If the operation wasn't done when we created 
		      // the event but now it is done, set the event
		      m_AsyncWaitHandle.Set();
		    }
		  }
		}
		return m_AsyncWaitHandle;
	    }
	}
	public Boolean IsCompleted {
		get {return Thread.VolatileRead(ref m_CompletedState) != c_sp; }}
	//endregion Implementation of IAsyncResult
}
\end{lstlisting}
\caption{$AsyncNoResult$} \label{noresult}
\end{figure}


	Interesting feature of $AsyncNoResult$, which is inherited by $AsyncResult$, is creation of a $EventWaitHandle's$ instance.
	It is not created in all cases and is created at most one in a $AsyncNoResult's$ life cycle.
	An instance of $EventWaintHandle$ is created only if the user explicitly called get method for $WaitHandle$ or
	if the $EndInvoke$ method was called and the operation is still pending.
	It means, that if you use callback and do not call "End" function, than no instance of $EventWaitHandle$ is created.
	Let us stress, that $EventWaitHandle$ is provided from an operation system and its instantiation is relatively slow.

	Field $name$ seems useless, but it allows "Begin" function to put its name in it, which can be used in logging or debugging.
	It will be described in following paraghaps devoted to design of "Begin" and "End" functions.

	Let us note, that $AsyncResutl$ adds no crucial logic except setting a result in $SetAsCompleted$ function and
	returning the result in $EndInvoke$ function. $AsyncResult$ use its base class $AsyncNoResult$ to implement the logic.
\begin{figure}[!hbp]
\begin{lstlisting}
public class AsyncResult<TResult> : AsyncResultNoResult {
	// Field set when operation completes
	TResult m_result = default(TResult);
	public AsyncResult(AsyncCallback asyncCallback, Object state,string name) : 
		base(asyncCallback, state,name) { }
	public AsyncResult(AsyncCallback asyncCallback, Object state) : 
		this(asyncCallback, state, null) { }
	//enable to set Result. AsyncNoResult enables to set exception.
	public void SetAsCompleted(TResult result, Boolean completedSynchronously) {
		// Save the asynchronous operation's result
		m_result = result;
		// Tell the base class that the operation completed 
		// sucessfully (no exception)
		base.SetAsCompleted(null, completedSynchronously);
	}
	// Allows to set both the exception and the result. Added for GetImage(..).
	public void SetAsCompleted(TResult result, Boolean completedSynchronously, Exception exception) {
		m_result = result;
		base.SetAsCompleted(exception, completedSynchronously);
	}
	new public TResult EndInvoke() {
		base.EndInvoke();// Wait until operation has completed 
		return m_result; // Return the result (if above didn't throw)
	}
}
\end{lstlisting}

\caption{$AsyncResult<T>$} \label{result}
\end{figure}

	Let us introduce an implementation of "Begin" and "End functions.
	They are the tools for manipulating e-Puck easily and they are the key functions of $IAsyncResult$ implementation.
	All the "Begin" and "End" functions' implemantaions are similar. The implemenataions look like $BeginGetIR's$ and $EndGetFtion's$ implementation from ~\ref{arexample}.
	The implementation of $BeginGetIR's$ and its "End" function is shown in figure ~\ref{beginsens}.
	All "Begin" functions use $Epuck's$ interface with $Okf$ and $Kof$ callbacks introducedi
	in subsection ~\ref{approach}.	

\begin{figure}[!hbp]
\begin{lstlisting}
public IAsyncResult BeginGetIR(double timeout, AsyncCallback callback, object state) {
	AsyncResult<int[]> a = new AsyncResult<int[]>(callback, state, logFunctionNames["BeginGetIR(..)"]);
	GetMikes(receivedSensors<int[]>, failed, a, timeout);
	return a;
}
static T EndSensors<T>(IAsyncResult ar) {
      AsyncResult<T> a = (AsyncResult<T>)ar;
      return a.EndInvoke();
}
public int[] EndGetFtion(IAsyncResult ar) { return EndSensors<int[]>(ar); }
\end{lstlisting}	
\caption{An example of "Begin" and "End" function for sensors.} \label{beginsens}
\end{figure}

	"Begin" function creates an $AsyncNoResult$ resp. $AsyncResult$ instance called $a$. They pass the supplied callback with its state object to
	$a$. Third argument of $a's$ constructor is name of the function.
	$BeginGetIR$ instantiate $AsyncResult<int[]>$, because $BeginGetIR$ expect array of $ints$ as its answer. The $Name$ field of $AsyncResult$
	is filled with the $string$ value from $logFunctionNames$ dictionary. The dictionary is set defaultly se to its key values, so
	the $Name$ in $BeginGetIR$ function is filled with "BeginGetIR(..)" value.
	After setting up the $a$ instance the $GetMikes$ function is called with $receiveSensors<int[]>$ and $failed$ methods as $Okf$ and $Kof$ callbacks.
	The $a$ instance is passed as the $state$ argument and is at disposal to $failed$ and $receiveSensors$ functions.
	The function $receiveSensors$ is called with generic parameter $int[]$, because $GetIR$ values expects array of $ints$ from sensor.
	The function, which control actuators, calls $received$ function as $Okf$ callback. See an example in figure ~\ref{beginact}.
	Sensor's methods as well as actuator's methods use $failed$ function as its $Kof$ callback. An exception is the
	$GetImg$ function, which use $failedBitmap$ callback instead.
	Last action of each "Begin" function is the return of instance $a$.

	Let us shortly introduce the "End" functions before we will focus on $Okf$ and $Kof$ callbacks used in "Begin" functions.
	There are two tasks of the "End" functions.
	First task  is to cast the $IAsyncResult$ argument to correct type of $AsyncResult$ or to $AsyncNoResult$ class.
	Second task is to call $EndInvoke$ method.
	If the "End" function is called with $IAsyncResult$ argument from a sensor command, as you can see in figure ~\ref{beginsens}, than the value from $EndInvoke$ is returned.
	If the $IAsyncResult$ argument is passed from "Begin" function, which controls an actuator, than $EndInvoke$ is called and nothing is returned. See figure ~\ref{beginact}.
	

\begin{figure}[!hbp]
\begin{lstlisting}
public IAsyncResult BeginMotors(double leftMotor, double rightMotor, double timeout, AsyncCallback callback,Object state) {
	AsyncResultNoResult a = new AsyncResultNoResult(callback, state,logFunctionNames["BeginMotors(..)"]);
	Motors(leftMotor, rightMotor, received, failed, a, timeout);
	return a;
}
public void EndActuators(IAsyncResult ar) {
      AsyncResultNoResult a = (AsyncResultNoResult)ar;
      a.EndInvoke();
}
\end{lstlisting}	
\caption{An example of "Begin" and "End" function for actuators.} \label{beginact}
\end{figure}
	
	The callbacks are called after the answer's arrival or after the timeout expiration.
	The callback allows to process the result of the operation.
	In $IAsyncResult$ interface the results are set via calling $SetAsCompleted$ method 
	on $AsyncNoResult$ resp. $AsyncResult$ instance.
	If the operation fails, the $Kof$ callback $failed$ is called. 
	In $failed$ function is called $SetAsCompleted$ method and an exception is passed to its first argument.
	See the first function $failed$ in figure ~\ref{Ikofs}.

	The only exception, which can return both the exception and the result, is $BeginGetPicture$ function.
	As the $Okf$ callback is used $receivedSensors<Bitmap>$, but special $Kof$ $failedBitmap$ 
	is called if an exception has been raised.
	The $Kof$ callback raise a special exception, if the img was captured and was only 
	delivered after timeout expiration.
	Implementation is shown in figure ~\ref{Ikofs}. 

	
\begin{figure}[!hbp]
\begin{lstlisting}
static void failed(object asyncNoResult) {
      AsyncResultNoResult ar = (AsyncResultNoResult)asyncNoResult;
      ar.SetAsCompleted(new ElibException(ar.Name + " command hasn't been confirmed in timeout"), false); 
}
static void failedBitmap(Bitmap pic,object asyncResult) {
      if (pic != null) {
        AsyncResult<Bitmap> ar = (AsyncResult<Bitmap>)asyncResult;        
        ar.SetAsCompleted(pic, false, new ElibException(ar.Name + " command GetPicture has not been confirmed in timeout, but picture is still available in AsyncResult<Bitmap>"));
      } else
        failed(asyncResult);
}
\end{lstlisting}	
\caption{$Kof$ callbacks for $IAsyncResult$} \label{Ikofs}
\end{figure}


	If the anwser is delivered in time, than the $Okf$ callback is called.
	The sensor's callback $receivedSensors<T>$ passes answer of $T$ type to its first argument.
	The actuators callback $received$ just pass null to its first argument, which indicates,
	that no exception has been raised.
	See the code below in figure ~\ref{Iokfs}.


\begin{figure}[!hbp]
\begin{lstlisting}
static void received(object asyncNoResult) {
	AsyncResultNoResult ar = (AsyncResultNoResult)asyncNoResult; ar.SetAsCompleted(null, false); 
}
static void receivedSensors<T>(T b, object asyncResIntArr) {
	AsyncResult<T> a = (AsyncResult<T>)asyncResIntArr;
	a.SetAsCompleted(b, false);
}
\end{lstlisting}	
\caption{$Okf$ callbacks for $IAsyncResult$} \label{Iokfs}
\end{figure}

\section{Summary of Elib interfaces}
\label{sec:suminterface}
	In previous three subsections the implementations of the two interfaces of $Epuck$ 
	and one $Sercom's$ interface have been depicted.
	$IAsyncResult$ is built on basic $Epuck's$ interface with typed $Okf$ and $Kof$ callback. 
	The basic $Epuck$ interface is itselft built on $Sercom's$ $Okf$ / $Kof$ interface.
	The purpose of the interfaces is to make programming e-Puck over Bluetooth easier and easier.
	The $IAsyncResult$ is most comfortable of the three interfaces. On the other hand usage of $Sercom's$ interface
	needs good knowledge of $BTCom$ protocol and it forces user process every answer of $BTCom$.

	Let us compare the possibilities and limitations of the interfaces against each other.
	The $Sercom's$ interface and $Epuck$ basic interface with $Okf$ and $Kof$ 
	have the same limitations and posibilities for the e-Puck is running BTCom version 1.1.3. 
	
	Every program written written using $Epuck's$ basic interface can be written
	in $Sercom$ by implementing $Epuck's$ interface as it is in Elib.
	On the other hand every program, which used $Sercom$ interface and communicates with $BTCom$
	version 1.1.3 on e-Puck, can be written using $Epuck's$ basic interface. 
	$Epuck's$ basic interface is a specialization of $Sercom$ for concrete version of $BTCom$
	protocol.

%%%%todo vyjasnit a vysvetlit, ze jde simulovat kof pomoci IAsyncResult
	The $IAsyncResult$ limits the role of $Kof$ callback, but does not limit the role of $Okf$ callback.
	Tf an user wants to implement $Okf$ logic using $IAsyncResult$ interface, he uses callback from $IAsyncResult$
	interface, which is passed to the "Begin" function.
	The callback is called after $received$ resp. $receivedSensor<T>$ function called $SetAsCompleted$ method
	on $a$ instance of $IAsyncResult$. Remind the implementation in ~\ref{Iokfs}.
	The $received$ and $receivedSensor<T>$ functions are called as $Okf$ callbacks from $Epuck's$ basic interface.
	See figure ~\ref{beginact} and ~\ref{beginsens} for confirmation.
	To conclude the $IAsyncResult$ callback is invoked in $Okf$ callback of $Epuck's$ basic interface.

	The limitation of $IAsyncResult$ arise from setting an exception in $Kof$ callbacks,
	which are used in $IAsyncResult's$ implementation.
	On the other hand the sample ~\ref{iasynckof} shows how to cope with the problem
	and how to simulate $Kof$ callback.
	The $Kof$ logic should be implemented if an exception is raised. 
	The exception is raised in callback passed to $IAsyncResult$ if the answer is not delivered in timeout. 
	The nearest place, where it can be catch is in the call of $EndInvoke$ method.
	$EndInvoke$ method is called on the $IAsyncResult$ instance. 
	The commom way for a user to invoke $EndInvoke$ method, is to call "End" method 
	on the instance of $Epuck$ with $IAsyncResult$ object as parameter. 
	It is done in figure below.
	The call of $ada.EngGetImage(ar_)$ gets the image and the callback function continues
	or the $EndGetImage$ function throws an exception, which is catch by $try-catch$ block.
	In $catch$ block is the user defined $kof$ function invoked.
	
	The logic of $Kof$ function from basic $Epuck's$ interface is maintained, because the userdefined
	$kof$ is called in same case when the $Okf$ is called. Both are invoked, if the $timeout$ expires.
	On the other hand the $kof$ uses an extra command to be invoked. In ~\ref{iasynckof} it
	is $ada.BeginStop$ command, which invokes $okf$. $Stop$ function would be the first command
	in $Kof$ logic implementation of $Epuck's$ basic interface.
	Second difference is that the the same $Kof$ is called from $EndGetImage$ and from the
	commands in body. In this example the same $kof$ is called for $EndGetImage$ and for
	$EndActuators$, which is the pair function of a $BeginMotors$ command from the body of $okf$ function.
	The exception's origin can be found out from $message$ property of exception, where is used $Name$ property of $AsyncNoResult$ instance,
	but it takes quite a lo effort.

	The unknown source of exception is as well as the extra invocation command minor problems, because
	there is usually only one $Kof$ callback function, which consist of more than one command. 
	The $Kof$ logic complicates the program, so it is neccessary keep it simple in $Epuck's$ basic interface.
	The lost answer usually completly breaks the logic of $Okf$ implementation. The appropriete solution is to put e-Puck
	at starting position of the behaviour. Usually commands to stop e-Puck are sent, the sensors are calibrated and a message to user or to logging file
	is sent.


\begin{figure}[!hbp]

\begin{lstlisting}
static void SimulatingKof_over_IAsResult(Epuck ada) {
      //the timeout is too small!
      ada.BeginGetImage(0.001, okf, ada);
}
static void okf(IAsyncResult ar_) {
      if (!endf) {
        //it can be called only as a callback of BeginGetImage in order to match EndGetImage ftion 3 rows below
        Epuck ada = (Epuck)ar_.AsyncState;
        Console.WriteLine("Okf has been called");
        try{
          //no EventWaitHandle created
          Bitmap b = ada.EndGetImage(ar_);
          
          // some work
          IAsyncResult ar = ada.BeginMotors(-1, 1, 0.1, null, null);
          //simulate image processig
          Thread.Sleep(20);
          ada.EndFtion(ar);
	  
	  //the timeout is too small!
          ada.BeginGetImage(0.01, okf, ada);
        } catch (ElibException) {
          //has to be fixed in kof
          ada.BeginStop(0.1, kof, ada);
        }
      } else
        endconfirmed.Set();
}
static void kof(IAsyncResult ar_) {
      if (!endf) {
        Epuck ada = (Epuck)ar_.AsyncState;
        //it can be called from any function because we call only EndFtion can be applied to every IAsyncResult in Elib
        ada.EndFtion(ar_);
        Console.WriteLine("kof has been executed");
        try {
          //do the repair actions
          IAsyncResult ar = ada.BeginStop(to, null, null);
          ada.EndFtion(ar);
          Console.WriteLine("The problem is fixed. Lets call okf!");
          ada.BeginGetImage(0.1, okf, ada);
        } catch (ElibException) {
          ada.BeginStop(0.1, kof, ada);
        }
      } else
        endconfirmed.Set();
}
\end{lstlisting}
\caption{Simulation $Kof$ using $IAsyncResult$}
\label{iasynckof}
\end{figure}


	We have concluded, that the $Sercom's$, basic $Epuck's$ and $ IAsyncResult$ interface, have equal power of implementing algorithms.
	Let us explore the demands and the load of operation systems (OS), if we use these interfaces.
	The sophisticated the interface is, the bigger demands on OS it has. It is a consequence of building one interface upon the other.
	Let us stress, that is true that every program written using $IAsyncResult$ interface, can be written with less or equal system resources using $Sercom's$
	interface. On contrary the problem is, that the programmers, which  use more complicated interface e.g $Sercom$, do not usually find better way, 
	than is designed by the richer interface e.g $IAsyncResult$.

	In fact $IAsyncResult$ is not much more demanding than $Sercom$ interface, if it is not missused.
	The only arrea, where $IAsyncResult$ does not keep up with $Sercom's$ interface, is extremaly frequent calling of $Kof$ callbacks.
	$IAsyncResult$ throw an exception for every $Kof$ callback invocation, on the other hand $Sercom's$ interface just needs to invoke a callback.
	$IAsyncResult$ need to performs other actions too, but they are quite fast. The raising and cathing an exception is significatly slower.
	On the other hand such behaviour, which extensively use $Kof$ callbacks, has very special purpose or is a bad programming example.
	See next chapter for guidelines how to use the interfaces.

	The only resource, which can be extensivly used in $IAsyncResult$ is $EventWaitHandle$. $EventWaitHadndle$ is a synchronization primitivum provided
	by OS. There is at most one $EventWaitHandle$ created for each instance of $IAsyncResult$ in Elib. On the other by using callbacks in Elib's $IAsyncResult$
	implementation it is creation of $EventWaitHandles$ completely avoided.

	Let us note that $Sercom's$ and simple $Epuck's$ interface are almost identical and therefore they have almost identical performance.
	$Epuck$ class adds answers processing and allows logging. The answers processing would do the user anyway. If the logging is off, the additional
	one if statements adds no overhead. 
	Chosing one interface before another in Elib does not significantly influence the performance of application.

	We put Elib to some tests. Let us introduce the results and its features.
	Compiled Elib library is 45 KB big.
	Using $IAsyncResult$ in "Bull" behaviour  TestElib consumes 8512KB of memory.
	Compare it with a simple a console application, which needs 4580KB of memory, or with Google Chrome, which consumes more than 30000KB of memory.
	 %csReadLineEmpty.exe 4580KB csReadLineEmpty.vshost.exe 15184KB
	 %TestElib.vshost.exe consumed 14108KB
	%todo musi se pridat jeden prikaz pred volani kof function a aby se rozlisilo mezi exceptionou z tela okf a z EndGetImage function tak se musi nastavit ruzne state obejcty

	todo profiling - zmerit spotrebu aplikace	
