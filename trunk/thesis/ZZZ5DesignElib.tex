%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                    %%%
%%% ©ablona bakaláøské práce na MFF UK %%%
%%%                                    %%%
%%% (c) Franti¹ek ©trupl, 2005         %%%
%%%                                    %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% POZOR: Úprava bakaláøské práce je závislá rovnì¾ na volbì jednostranného resp. oboustranného tisku.
%%%        Bli¾¹i informace naleznete v dokumentu Úprava bakaláøské práce, který se nalézá na adrese:
%%%        http://www.mff.cuni.cz/studium/obecne/bplayout/pok12mo4.pdf

\documentclass[12pt,notitlepage]{report}
%\pagestyle{headings}
\pagestyle{plain}

\frenchspacing % aktivuje pou¾ití nìkterých èeských typografických pravidel

\usepackage[latin2]{inputenc} % nastavuje pou¾ité kódování, u¾ivatelé Windows zamìní latin2 za cp1250
%\usepackage{czech}
\usepackage[czech]{babel}
\usepackage{a4wide} % nastavuje standardní evropský formát stránek A4
%\usepackage{index} % nutno pou¾ít v pøípadì tvorby rejstøíku balíèkem makeindex
%\usepackage{fancybox} % umo¾òuje pokroèilé rámeèkování :-)
\usepackage{graphicx} % nezbytné pro standardní vkládání obrázkù do dokumentu
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage[left=3cm]{geometry} % nastavení dané velikosti okrajù

%\newindex{default}{idx}{ind}{Rejstøík} % zavádí rejstøík v pøípadì pou¾ití balíku index

\title{Object Oriented Library for Controlling an e-Puck Robot}   % tyto dvì polo¾ky jsou zde v podstatì formálnì, ve skuteènosti nejsou nikde 
\author{Ondøej Plátek} % dále v dokumentu pou¾ity

%\date{}

\begin{document}
\chapter{Elib design}
	Elib is a library for a remote control of e-Puck. 
	At first place the possibilities of programming e-Puck are depicted.

	Next section covers the drawbacks and advantages of asynchronous remote control programming of e-Puck.
	Furthermore key features of Elib are presented together with crucial decisions, which
	lead to properties of Elib. 
	The features will be confronted by their alternatives and the differences will be discussed.

	After that the main classes $Sercom$ and $Epuck$ are introduced. Following two parts 
	describe implementation either of $Sercom$ or $Epuck$. 
	In part devoted to $Sercom$ is main stress on design of Bluetooth communication processing.
	$Epuck$ interfaces are the main topic of rest of this chapter. 
	
	At last will be introduced tools and examples, 
	which make easier a development of programs with Elib.
\section{Approaches to e-Puck programming}
	E-Puck is distributed with several programs in its flash memory. 
	Most of the programs implements simple behaviours, which introduce e-Puck sensors and actuators.
	There is a behaviour, which made e-Puck go to light. If another behaviour is running, e-Pucks
	reacts to clapping and it turns around to source of a clap. An interesting behaviour mades
	e-Puck cry, if its falling.
	 
	BTCom and e-Puck bootloader belong to different classes of programs. BTCom allows e-Puck to communicate with
	other devices via Bluetooth. It defines a BTCom protocol, which works in two modes. Text mode has commands for
	all sensors and actuators except it does not allows take a picture with an e-Pucks camera. 
	The commands and the answers are short text messages.
	On the other hand binary mode can take and send a picture from e-Puck, but it implements fewer commands
	then text mode, so it does not control all sensors and actuators. All commands and answers are sent in binary mode,
	which save a space of a message.
	 
	Bootloader, officially called Tiny Bootloader%todo citation
	, is only wired program on e-Puck. It downloads	other programs to e-Puck via Bluetooth. 
	Tiny Bootloader has its counterpart, a graphical PC application,
	which allows users easy download hex files to e-Puck.
	A hex file for e-Puck is compiled C program for e-Puck's dsPic microchip. 
	%todo citace http://en.wikipedia.org/wiki/Hex_file
	 
	All mentioned programs including Tiny Bootloader use C library, which interface the devices on e-Puck. 
	The library and the programs are published under open source licence at http://www.e-puck.org .%todo url
	 
	If e-Puck is turned on, e-Puck starts running one of downloaded program according a selector 
	position. E-Puck's selector switch is a located on the main board of e-Puck.
	If you want to run another program you have to switch selector to another position
	and hold a second a reset button on e-Puck.	Selected program is loaded from flash memory
	to RAM memory and immediately executed.	
	 
	Suppose there is correct C code for e-Puck's processor. What has to be done to run the program?
	Firstly it has to be compiled and linked, after that transformation to a hex file is necessary,
	because e-Pucks's dsPic is 16 bit processor.
	Turn your Bluetooth and e-Puck on. Pair the robot and your computer. Enter the PIN, 
	which is needed to pair the devices. PIN is a number, which is on e-Pucks body.
	The OS opens a serial port for Bluetooth communication.
	Start Tiny Boatloader, select the hexfile and the opened port. Follow the instructions,
	which will tell you to press a reset button on e-Puck. Press it only for about a second.
	If you are lucky, it starts a download of your program.
	Tiny Bootloader tells when the download finishes. Last thing to do is to reset e-Puck
	and the e-Puck is running your program.
	 
	Your program was written to e-Puck's flash memory according selector position.
	If a program had been saved under this selector position, it was deleted.
	 
	It seems complicated, but there is another way. 
	Turn selector to position, under which is loaded BTCom, and press reset button.
	Now is BTCom running.  Pair your PC with e-Puck as described above and use the open port
	to control e-Puck.
	BTCom starts running in text mode, so its possible to use a terminal to communicate with e-Puck.
	E.g Hyperterminal on Windows or on Linux you write directly to serial port using command line.
	A program can control e-Puck via BTCom protocol too, but it must processed the commands ant their replies.
	 
	Nice example of accessing sensors and actuators over Bluetooth is e-Puck Monitor. 
	E-Puck Monitor is an open source graphical application written in C++, which uses BTCom protocol. 
	It can send and process answers to every sensor and actuator.
	It presents values of all sensors on one screen. Actuators can be controlled by mouse.
	E-puck Monitor's big drawback is its freezing. It is not responsible, because it waits synchronously to some answers.
	If a Bluetooth connection with e-Puck breaks or the answer is lost, the application stays unresponsive.
	Epuck Monitor source code is also available as open source from  http://www.e-puck.org. %todo url
	 
	Downloading a hex file to e-Puck's microchip and remote control over BTCom protocol are two alternatives
	of controlling e-Puck.
	 
	Using BTCom user do not have to download any file to e-Puck's microchip.
	It is great advantage, because the length of developing cycle of program to e-Puck's processor.
	The developing cycle consist of	writing a code, compiling it, loading it, debugging it and correcting it.
	In following section the drawbacks will be described in detail and it will be confronted with
	remote control.
\section{Profiting from remote control}
	The applications, which use BTCom and its protocol, run a whole algorithm on PC and BTCom just 
	execute the commands and get the values from sensors. Imagine you have a library, which process the commands
	and their replies. Your program uses the library and just asks the library for sensor values and
	gives the library commands what to do. The life cycle of developing a program is still writing a code, compiling it, debugging and rewriting. Important is that downloading part is missing.
	 
	It is so important, because downloading a program to e-Puck takes the most time and is the most unreliable part except debugging.
	The quality of debugging also differs a lot between these two attitudes.
	 
	If a program is downloaded to e-Puck, there are only e-Puck actuators for a feedback.
	It is not much because if something goes wrong, it is impossible to say if the program stopped running,
	or e-Puck is waiting to sensors values, or battery is down however the indicator of battery shows or e-Puck just can not move.
	Discovering the problem, even if it is the low battery, takes one or two loops of loading and compiling the program.
	Loading a program could last even a couple of minutes. It drives a lot of people crazy.
	 
	On the other hand a developer has all variables under control. If he set the breakpoints
	right, the logic should not be damaged. Of course like in every interactive application
	the breakpoints breaks the logic at a lot of places, but here is clear, where the places are.
	The breakpoint damages the logic of application only if they are set between two commands,
	which first has sent a command and the second is waiting to it.
	Here is the interaction between the program and robot. In other cases it can be interaction
	between program running a server and its clients.
	 
	A programmer, which controls robot remotely, can of course debug with tools of his programming environment.
	He is able to use e-Puck's sensors too. Also his own logging program can be useful. Furthermore other sensors connected to his computer help.
	All this can be utilise, because a computer has usually much more resources than e-Puck has.
	 
	If remote control is used, it can be said that the intelligence 
	is located on a computer. However if you load a program with Tiny Bootloader 'the intelligence'
	is located on e-Puck.
	 
	The resources are useful first of all for implementation of the program and not only for
	its debugging. E-Puck for example takes picture smaller than 3200 bytes, but it is still
	a lot of work for e-Puck for complicated image processing. It is faster to process the picture
	on a computer. Also implement a neural network or even genetic algorithm on 8kB memory
	is very difficult.
\section{Design of BTCom. What does it mean for Elib?}
	 
	Let $A$ be a PC and $B$ be an e-Puck robot. $A$ controls $B$ over BTCom protocol. BTcom program located on $B$ 
	replies to all commands sent from $A$.
	The answer of BTCom always begins with the first letter of relevant command.
	If the command requires some sensor values, the value is attached to the first letter and
	sent. Otherwise the first letter is sent alone. Each answer ends by 
	$\backslash$r$\backslash$n escape sequence.
	List of all text commands available see below.\\
	\lstset{basicstyle=\tiny}
	\begin{lstlisting}
	 	"A"         Accelerometer
		"B,#"       Body led 0=off 1=on 2=inverse
		"C"         Selector position
		"D,#,#"     Set motor speed left,right
		"E"         Get motor speed left,right
		"F,#"       Front led 0=off 1=on 2=inverse
		"G"         IR receiver
		"H"          Help
		"I"         Get camera parameter
		"J,#,#,#,#" Set camera parameter mode,width,heigth,zoom(1,4 or 8)
		"K"         Calibrate proximity sensors
		"L,#,#"     Led number,0=off 1=on 2=inverse
		"N"         Proximity
		"O"         Light sensors
		"P,#,#"     Set motor position left,right
		"Q"         Get motor position left,right
		"R"         Reset e-puck
		"S"         Stop e-puck and turn off leds
		"T,#"       Play sound 1-5 else stop sound
		"U"         Get microphone amplitude
		"V"         Version of SerCom
	\end{lstlisting}
	  
	  
	The answers of Sercom from $B$ allows $A$ to know that the sent command was received and
	executed. 
	 
	Two main questions, which effects design of Elib, arise from the BTCom structure.
	Does Elib limit the waiting time for answer from $B$?
	How fast Elib allows $A$ send the commands to $B$?
	 
	At first I have to stress that sending commands from Elib does mean sending textual or binary commands
	using BTCom not calling functions of Elib to send the BTCom commands. 
	 
	It is necessary to understand that not only executing a BTCom command, but also a transfer of a command and a transfer of
	reply take insignificant amount of time. It is measured from a computer processor's point of view, because
	it is the processor, who is waiting to serial port, which is sending the message.
	 
	Back to question how should Elib limit sending of the commands.
	Because sending commands takes a while, sending is performed asynchronously. 
	Due to asynchronous sending, users do not have to wait to the end of sending previous command and
	can send next before the first has finished.
	Therefore the commands can be queued in a serial port buffer. Unfortunately the buffer is usually not very big and can easily
	overflow. This is the reason for implementation Elib's buffer, a queue, which will save the commands
	from overflowing the buffer and so the queue allows sending command asynchronously without useless losses.
	 
	Is problem with sending finished? Not for e-Puck. If the commands would be sent to fast,
	the input buffer would have the same problem, because e-Puck's processor does not keep up emptying the buffer.
	It would be flooded and and some commands would be overwritten.
	So Elib has to check if the Bluetooth is not able to send commands too fast and possible slow it down.
	How fast can e-Puck receive commands? Experiments showed, that gaps around 0.02 are critical.
	 
	What about waiting to the answer?
	Clearly we have to wait more than is the minimum transfer time from a computer to e-Puck and also
	the transfer time of the answer.
	The times all almost identical for actuators, but sensors messages carries more data on the way back.
	An extreme is a command for taking a picture. Sending command to e-Puck last about 0.02 s, but
	the answer needs more than 0.2 s for a transfer.
	 
	Because waiting for the answers takes even longer time than sending a command,
	it is performed asynchronously in Elib.
	 
	Due to asynchronous design we can afford to wait as long as we can. 
	Big possible variability of waiting time force Elib to let the user decide how long will
	be Elib waiting for a command. Elib does not limit the waiting time from bottom,
	because the convenient values differs according state of battery on e-Puck strength of Bluetooth device
	on a computer and so on. In examples, which will be introduced in next chapter, the waiting times, 
	in code called $timeout$, are set to the bottom limit.
	 
	What do we know now? Sending takes insignificant amount of time.
	Sending commands are queued, because otherwise they could be overwritten in buffer.
	Receiving an answer takes even more time than sending a command from computer.
	Because sending is a good idea to implement asynchronously, the more implementing receiving
	answers asynchronously is sensible.
	What means asynchronous implementation in case of Elib? What is done if the answer receives in time
	and what if not? These questions are answered in next section called Asynchronous programming model for Elib.
\section{ Asynchronous programming model (APM) for Elib}
	It was already mentioned, that asynchronous call of function is convenient if the
	classical synchronous call let the processor waiting for instance to a device.
	In e-Puck's case the device is serial port. 
	 
	Synchronous communication using BTCom 
	is implemented in $Epuck$ Monitor.\cite{monitor} It waits not only to send the command, but
	it also waits on answer.
	 
	Waiting for the answer is typical situation and is worth to do it asynchronously. Graphical 
	applications explicitly requires to stay responsive. If they are not they freezes.
	On the other hand asynchronous programming is much more complicated than synchronous programming.
	The goal of Elib is to hide the complications of APM and offer an interface,
	which allows Elib perform sending and receiving messages asynchronously and
	which allows a programmer control e-Puck without unnecessary complications.
	 
	Elib has two main classes and two interfaces implemented.
	$Sercom$ is a public class, which wraps serial communication.
	$Epuck$ class represents an instance of a e-Puck robot and uses $Sercom$ internally.
	The interface of $Sercom$ for sending commands takes a
	string for command, two functions, class object and an integer.
	String specifies a type of command, the integer represent the $timeout$.
	First function is called with the class object if the answer is delivered in time.
	Second function is called if the $timeout$ elapsed and the answer has not arrived.

	Actually $Epuck's$ commands have two interfaces. First is directly based on the interface of 
	$Secom's Write(..)$ function it only removes the string argument, which the functions
	use implicitly.
	Second interface of $Epuck$ commands is based on the first $Epuck's$ interface. 
	It also accept $timeout$, an instance of object class, one function, but it returns 
	an implementation of $IAsyncResult$ interface, which will be introduced later.

%%%%%%%% csharp c# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstdefinelanguage{cs}
  {morekeywords={abstract,event,new,struct,as,explicit,null,switch
		base,extern,object,this,bool,false,operator,throw,
		break,finally,out,true,byte,fixed,override,try,
		case,float,params,typeof,catch,for,private,uint,
		char,foreach,protected,ulong,checked,goto,public,unchecked,
		class,if,readonly,unsafe,const,implicit,ref,ushort,
		continue,in,return,using,decimal,int,sbyte,virtual,
		default,interface,sealed,volatile,delegate,internal,short,void,
		do,is,sizeof,while,double,lock,stackalloc,
		else,long,static,enum,namespace,string, },
	  sensitive=false,
	  morecomment=[l]{//},
	  morecomment=[s]{/*}{*/},
	  morestring=[b]",
}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	language=cs,
	basicstyle=\tiny
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	showstringspaces=false,
	basicstyle=\small,
	numberstyle=\footnotesize,
	numbers=left,
	stepnumber=1,
	numbersep=10pt,
	tabsize=2,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	aboveskip={1.5\baselineskip},
	columns=fixed,
  	keywordstyle=\color[rgb]{0,0,1},
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color[rgb]{0.627,0.126,0.941},
	extendedchars=true,
	backgroundcolor=\color{lbcolor},
}

%%%%%%%%%%%%%%%%%%%%%%%%% end charp definition %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
	\begin{lstlisting}[language=cs]
	public class Sercom {
		public void Write(string command, RCallback okf, NRCallback kof,object state, double timeout) {
			//... the body of function
		}
	}

	public class Epuck {
		public void Stop(OkfActuators okf, NRCallback kof, object state, double timeout) {
			//example of interface directly based on Sercom's interface
		}
		public IAsyncResult BeginStop(double timeout, AsyncCallback callback, Object state) {
			//example of IAsyncResult interface implementation
		}
	}
	 
	\end{lstlisting}
%	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%todo%%%%%%%%%%%%%%%
%	Asynchronous waiting means, that main application is running in one thread and the task, 
%	which is waiting, is running in another thread. Because processor switches between all threads
%	frequently enough that the user perceives the threads or tasks as running at the same time.
%	 
%	 
%	Common synchronous implementation is: $A$ sends a command and waits to an answer from $B$, 
%	process the answer, then $A$ sends next command and so on.	
%	All code from $A$ runs in one thread. It is the simplest and the fastest of all implementation, 
%	because the thread waits the minimum time and 
%	nothing more is implemented. Problem is if the one of the answer does not arrive, because the
%	the program does not count with such situation and waits until this answer arrives.
%	It blocks a whole application.
%	If you use such application and one of the desired answer is not delivered, you have to kill 
%	the process and restart the application.
%	 
%	The desired answer is undelivered surprisingly frequently.
%	If I run an application, which controls e-Puck, I often forget to turn Bluetooth on.
%	It cause the answer not to be delivered, because the command is not even sent.
%	Another example is if you drive e-Puck and it leaves the room and looses the Bluetooth signal.
%	 
%	An asynchronous application, which control e-Puck from PC, should solve the undelivered 
%	answer problem, should not send the commands too fast and should not also rely on user, 
%	who sometimes forget to turn Bluetooth on. If the application solves all three problems,
%	such application remains responsive under all circumstances and guarantee good control of e-Puck.
%	 
%	Asynchronous library for e-Puck should hide implementation of reading 
%	answer from Bluetooth, implementation of writing to Bluetooth and pairing sent commands with convenient answers. 
%	On the other hand common usage should offer public functions, which
%	replace text commands. The public functions allows programmer write human readable code and
%	also the functions should check their parameters to commands. Validating parameters and wrapping
%	commands with functions ensures, that programmers application send reasonable commands to BTCom.
%	To conclude an asynchronous library should allow programmer to forget about communication over
%	Sercom protocol	and let him concentrate on parts of application, which implement behaviours, that
%	control robot.
%
	
\end{document}
				
